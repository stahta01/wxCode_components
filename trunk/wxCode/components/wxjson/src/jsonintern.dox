
/*! \page pg_json_internals wxJSON internals


\li \ref json_internals_intro
\li \ref json_internals_cow
\li \ref json_internals_cstring
\li \ref json_internals_integer
\li \ref json_internals_array
\li \ref json_internals_map.
\li \ref json_internals_compare
\li \ref json_multiline_string
\li \ref json_comment
\li \ref json_symbols





\section json_internals_intro Introduction

The wxJSONValue class is much like a \b variant type which can hold
various types (see the documentation of the wxWidgets' \b wxVariant class).
The JSON value class is a bit different from wxVariant because it cannot hold
whatever type you want but only the following:

\li a NULL value
\li an integer value
\li an unsigned integer
\li a double
\li a boolean
\li a C string
\li a wxString object
\li an array of wxJSONValue objects
\li an map of key/value pairs where \e key is a string and \e value can be any
	wxJSONValue object

The type of the JSON value contained in a wxJSONValue object is one of the
following constants:

\code
 enum wxJSONType {
    wxJSONTYPE_EMPTY = 0,
    wxJSONTYPE_NULL,
    wxJSONTYPE_INT,
    wxJSONTYPE_UINT,
    wxJSONTYPE_DOUBLE,
    wxJSONTYPE_STRING,
    wxJSONTYPE_CSTRING,
    wxJSONTYPE_BOOL,
    wxJSONTYPE_ARRAY,
    wxJSONTYPE_OBJECT
 };
\endcode


There is no need to specify the type of a wxJSONValue object: it is
automatically set when you construct the object or when a value is
assigned to it. For example:

\code
 wxJSONValue v1( 10 );     // integer type
 wxJSONValue v2( 12.90);   // double type
 v1 = "some string";       // now 'v1' is of type string

 wxJSONValue v3;           // an 'empty' value (=not initialized)
 v3.Append( 10 );          // 'v3' is now of type wxJSONTYPE_ARRAY
\endcode

The only exception to this is when you want to set the wxJSONTYPE_EMPTY.
Note that you should cast the wxJSONTYPE_EMPTY constant to a wxJSONType type
because some compilers may assume the constant value to be an \b int:

\code
 wxJSONValue value( (wxJSONType) wxJSONTYPE_EMPTY );
\endcode


Starting from version 0.4.0 the internal representation of a JSON value
has totally changed because of the implementation of the \e reference
\e counting tecnique also known as \e copy-on-write.
Now the wxJSONValue class does not actually contain any data: every
instance of this class holds a pointer to the actual data structure
defined in the wxJSONRefData class.
The structure contains a special data member that counts the number
of instances of wxJSONValue objects that share the data.

\par The wxJSONValueHolder structure

All data is stored in the wxJSONRefData class which is just like a
simple structure: the class does not define an interface for accessing
data: it only defines the data members and the ctors and dtor.
The interface is totally defined in the wxJSONValue class which, in
turn, does not contain any data (with the exception of the pointer to
referenced data).

The data structure holds the type of the JSON value, the JSON value itself,
the comment lines, if any, etc. To know more about the individual data
member defined in the class see the documentation of wxJSONRefData.

\code
  struct wxJSONValueHolder  {
    int                  m_valInt;
    unsigned             m_valUInt;
    double               m_valDouble;
    const wxChar*        m_valCString;
    bool                 m_valBool;
    wxString             m_valString;
    wxJSONInternalArray  m_valArray;
    wxJSONInternalMap    m_valMap;
  };
\endcode

Unlike in previous versions, the actual JSON value is not held in an
\b union but in the wxJSONValueHolder structure: this causes some memory consumption
but allows to store the actual values and not pointers to them.
Since ANSI C++ does not permit to store in a union classes and
structures that have constructors, the \b wxString, the \b wxObjArray
and the \b wxHashMap objects cannot be stored in the union.

The following code fragment instantiates a wxJSONValue object that contains
an \b integer type.
The image shows the internal representation of the value.
Note the \c wxJSONValue::m_refData data member that points to the actual
data structure and the \c wxJSONRefData::m_refCount data member that counts
how many JSON value objects share the data structure (one, in the example):

\code
  wxJSONValue v1( 12 );
\endcode


<img src="images/cow01.png">



\section json_internals_cow wxJSON internals: copy-on-write

Reference counting is very simple: if you copy an instance of a wxJSONValue
object, the data contained in the wxJSONRefData structure is not
really copied but, instead, it is shared by the two JSON value objects
which data pointer points to the same memory area.
Here is an example:

\code
  wxJSONValue v1( 12 );
  wxJSONvalue v2( v1 );
\endcode

<img src="images/cow02.png">


Reference counting is implemented in many wxWidget's classes such as
wxBitmap, wxImage, etc but the wxJSONValue class is a bit different
because objects of this class may contain other wxJSONValue objects and
they can be nested to a virtually infinite level.
This cause references to not being propagated in the hierarchy.
Also, because values are accessed using the subscript operators -
which are \b non-const functions - COW for wxJSONValue objects is not as
efficient as we may expect.

In the following paragraphs I try to explain what happens when you
make a copy of a wxJSONValue and then call some non-const functions
on one of the two instances.




\subsection json_internals_cow_array Making a copy of an array type.

In the following example I create an array type and set a value to the
fourth element.
The subscript operator automatically creates the first for elements
and initializes them to a \b null value.
Then, the integer value is assigned to the fourth element by the
assignment operator.
Note that the first three array's element share the same data: this
is because the subscript operator automatically creates all instances
of the items until the requested index.
Needed items are created by copying (using COW) a temporary NULL
JSON value:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
\endcode

<img src="images/cow08.png">

Writing the value to a JSON text document we get the following:

\code
 [
    null,
    null,
    null,
    12
 ]
\endcode

Now copy the \b v1 JSON value to a \b v3 value.
Note that the root JSON data structure is shared by the two instances.



\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v3(v1);   // make a copy of 'v1'
\endcode

<img src="images/cow09.png">



We already noted that the three \b null values in the array share the same data
structure but because the root value is shared we only have 
a reference count of THREE for the NULL values.
In fact, the data is shared by SIX JSON value objects: 3 items in \b v1 plus
3 items in \b v3 (six values in total) but as the parent object is shared,
the wxJSONRefData::m_refCount data member only counts 3 shares.


\subsection json_internals_cow_write Writing to a shared data


\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v3(v1);   // makes a copy of 'v1'

  v3[1] = 2;            // change the value of the second array's element
\endcode

When we change a value of an array's element we would expect that a real
copy of only that array's element is done and it is assigned the new
value.

We are wrong. In fact, the wxJSONValue object makes a copy of the
whole root object \b v3. Why?
The answer is simple: the first impression is that the assignment operator
is called for the second array element of \b v3 and this would cause a
real copy of that array's element.
In reality, \b before calling the \b operator= memberfunction the
code fragment seen above must return a reference to the second
element of \b v3's array.
This reference is returned by the \b operator[] (the subscript operator)
which is itself a \b non-const memberfunction.
So, the subscript operator of the root value object makes a real copy
of the referenced data.
All array's elements are copied from \b v1's instance to \b v3.
You may notice from the memory dump that the copy of elements is
not a real copy but it uses COW.
Below you find the memory dump of the two object after we had changed
one array's element.
As you can see, each root value has now an exclusive copy of the
array:

<img src="images/cow10.png">




In order to avoid the copy of the top-level array type we have had to
use a \e const member function to access the second array's element.
Note that we cannot use the wxJSONValue::ItemAt() function because
this function returns a copy of the data not a reference to it:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  // does not work!!! what we do is to change a temporary copy
  // of the second array's element
  v2.ItemAt( 1 ) = "value changed";
\endcode


The only suitable function is the wxJSONValue::Find() function which is,
unfortunately, protected so it cannot be called from outside the
class.

Another drawback of using non-const subscript operators is that 
the copy operation is done also when we do not write to the
JSON value object but also when we read from it.
This is an example:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  int i = v1[3].AsInt();   // read from 'v1'
\endcode

Because the \b operator[] memberfunction is non-const, the read 
operation causes the wxJSONValue class to make an exclusive copy
of shared data even when the access to the value is only for
read purposes.
The good news is that we can use wxJSONValue::ItemAt() in this case
thus avoiding the copy operation of the shared data (
OK, tested see \c samples/test11.cpp function \c Test51() )

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  int i = v1.ItemAt( 3 ).AsInt();
\endcode

The problem is that we can use \c ItemAt() for only one level in
the JSON value's hierarchy.

So is COW totally useless? No, it is not!

Even when using subscripts operators, the real copy of shared data
is done only until the parent of the requested level: every
other JSON value objects of the same level and of inferior
levels are not really copied: COW is used for all of them.
In the following image you see that in the above example of a
four element's array, the JSON array value \b v1 is copied to
\b v3 but the individual items are not really copied because
3 items of \b v1 and 2 items of \b v3 refer to the same
referenced data (the NULL value):

<img src="images/cow11.png">

In this example, the array's items are NULL values, thus the
time that was saved in the COW in not really much but remember
that an array's item may contain another array which may contain
one or more key/value hashmaps, which may contain one or more
array which .... and so on.



\section json_internals_cstring wxJSON internals: the C string type


You may ask yourself why there are 2 different constructors for strings.
For convenience, you may think, in order to save an implicit conversion
from \b const \b wxChar* to \b wxString.
The answer is: NO. The two constructors store the string in a very
different way:

\code
  wxJSONValue( const wxChar* str );
  wxJSONValue( const wxString& str );
\endcode

Both two ctors store strings and they could be
stored just as \b wxString objects. In fact, this is the default
behaviour of the class if the \c WXJSON_USE_CSTRING macro is not defined.

If this macro is defined, however, the first ctor stores the pointer in the
\c wxJSONValue::m_value data member assuming that the string is statically
allocated and it does NOT copy the string.
This behaviour saves a string's copy which can be time-consuming
but, on the other hand, you must be sure that the pointed-to
buffer is not freed / deallocated for the lifetime of the wxJSONValue
object (this is always true for static strings).
The following code fragment is an example on how to use the static
string type:

\code
  wxJSONValue aString( _T("This is a static string"));
\endcode

The code above is correct, because the pointed-to string is really
statically allocated (and it cannot even change).

The following code is not correct and it would probably result
in a SEGFAULT when you try to access the wxJSONValue data.
The problem is that the string is constructed on the stack which
will be deallocated when the function returns.
So, the returned JSON object contains a pointer to a deallocated
memory area.

\code
  // Example 1
  wxJSONValue MyFunction()
  {
    char buffer[128];
    snprintf( buffer, 128, "This is a string constructed on the stack");
    wxJSONValue aString( buffer );
    return aString;
  }
\endcode

The code above should be written as follows:

\code
  // Example 2
  wxJSONValue MyFunction()
  {
    char buffer[128];
    snprintf( buffer, 128, "This is a string constructed on the stack");
    wxJSONValue aString( wxString( buffer));
    return aString;
  }
\endcode

Now it is correct because the \b wxString object holds a \b copy of the
string buffer.
Note that if the \c WXJSON_USE_CSTRING macro is not defined, there is no need
to actually construct a temporary wxString object in order to force the
wxJSONValue class to create an instance of the wxString object: it is
automaticlly created by the wxJSONValue( const wxChar*) ctor.
This mean that you can use use the code in \b Example \b 1 without
worry about C-strings.
By default, the wxJSON_USE_CSTRING macro is \b not defined.

If your application uses many static strings that never changes,
you can save time by defining the symbol when compiling the wxJSON library

\b NOTES: the static C-string type value is, probably, useless and, in
fact, it is never used in wxJSONValue by default.
The C string value is useless because the only reason for using it
is speed: time is saved when no string-copy operation is performed.
But the \b wxString object uses \e copy-on-write to avoid unnecessary
copies so it is much more wisely (and SAFE) to never use C-strings.


\section json_internals_integer 64-bits and 32-bits integers

Starting from version 0.5, the \e wxJSON library supports 64-bits
integers but only on those platforms that have native support for
64-bits integers (currently win32 and GNU/Linux, for sure).

All integer types (and unsigned integers, too) are stored in a
64 bits integer storage of type \b wx(U)Int64 which is the wxWidget's
platform-independent data type for representing a 64-bits integer:
this data type is a \b tydepef for the underlying compiler / platform-dependent
type, for example, \b __int64 on MSVC/win32 and \b long \b long on
GNU/Linux systems.
To know more about the wxWidget's 64-bits integer stuff read the
documentation of the \b wxLongLong class.

When stored in the wxJSONValue class, the integer value is set of a generic integer
type: wxJSONTYPE_INT or wxJSONTYPE_UINT regardless its size: in other
words, no matter the type of the original value  (\b int or \b long \b long \b int) 
or the numeric weight of the value.
The only thing that matters is the sign of the value (unsigned or not).
For this reason, the \c wxJSONValue::Is(U)Int function returns
TRUE if the stored value is of type (unsigned) integer which is just
like in the previous versions of the library and also is compatible
with platforms that do not support 64-bits integers.
Also, in order to remain compatible with older 0.x versions,
the \b wxJSONValue::GetType() memberfunction just returns the generic
integer type in both 32-bits and 64-bits platforms regardless the
actual size of the integer.
I added four constants in the \b wxJSONType enum type:

\li wxJSONTYPE_INT32
\li wxJSONTYPE_UINT32
\li wxJSONTYPE_INT64
\li wxJSONTYPE_UINT64

but they are, by now, unused because returning them from the \b GetType()
function, I will break compatibility with the past and I do not want to
do this in \b 0.x versions.
Maybe, when version \b 1.x will be released, I will evaluate the opportunity
of an incompatible release. 

If the platform natively supports 64-bits integers, then the wxJSONValue
class defines some other functions related to the integer's storage size
so that the user knows about the size of the stored integer:

\li \c Is(U)Int32: the function only returns TRUE if the value stored in
	the JSON value object is of type (\b unsigned) \e integer and the number
	represented fits in a 32-bit (unsigned) integer data type.

\li \c Is(U)Int64: the function only returns TRUE if the value stored in
	the JSON value object is of type \b wx(U)Int64 and the number
	represented is too large to fit in a 32-bit integer data type.

\li \c As(U)Int32(): the function returns the low-order 32-bits of the
	integer stored in the wxJSONValue class. Note that the function
	does not check that the returned value fits in a 32-bit (unsigned)
	integer.

\li \c As(U)Int64(): the function returns the 64-bit integer as it is
	stored in the value object.

Also note that in order to remain compatible with older 0.x versions, the
\c wxJSONValue::As(U)Int function behaves exatly as in the past on
64-bits and 32-bits platforms: the function just returns a (unsigned) \b int
data type although on 64-bits platforms, the function also wxASSERTs that
the number stored fits in a 32-bit integer.

On the other hand, the functions \c As(U)Int32 does not wxASSERT that the
value fits in a 32 bit storage: these functions just returns the JSON
value object as a 32-bits integer: wrong results may be returned if the
value is too large for that storage size.

This organization let us to remain compatible with older 0.x versions of
the \b wxJSON library but allows new applications to get 64-bit support
on platforms that natively support it.
The following are some examples:

\code
  // an old application that does not know nothing about 64-bits
  // integer support (the app only uses 32-bit integers, as in the
  // previuos versions)
  int i;
  wxJSONValue v1 = 128;
  if ( v1.IsInt() )  {
    i = v1.AsInt();
  }
  switch ( v1.GetType() )  {
    case wxJSONTYPE_INT :
      i = v1.AsInt();
    case wxJSONTYPE_UINT :
      ui = v1.AsUInt();
    ...
  }
\endcode

Note that a new application that knows about 64 bits support but does never
use so large numbers, just use the same code of the old application which
does not know anything.
If the value stored in the JSON value object is too large, the \c As(U)Int
memberfunction fails with an ASSERTION failure. This is good, because
the JSON text read by the application needs a code rewriting.

If an application uses very large integers, it may just use 64-bits storage
for all integer types:

\code
  // a new application that needs 64-bits integers
  wxInt64     i64;
  wxJSONValue v1( 128 );

  if ( v1.IsInt() )  {    // calling IsInt64() is an error!!!
    i64 = v1.AsInt64();
  }
  switch ( v1.GetType() )  {
    case wxJSONTYPE_INT :
      i64 = v1.AsInt64();
    case wxJSONTYPE_UINT :
      ui64 = v1.AsUInt64();
    ...
  }

  // for some purposes, the new application just uses 32-bits ints
  int         i32;
  wxJSONValue v2( 6545322 );

  wxASSERT( v2.IsInt32() );
  i32 = v2.AsInt32();
\endcode

Note that all 64-bits integer memberfunctions are only available if
the platform on which runs your application natively supports
64-bits integers.
This is in constrast with the \b wxLongLong class which is also
available on 32-bits platforms.

If your system natively supports 64-bits integers but you do not want
to include this feature in the \b wxJSON library, you can define the
following macro when compiling the library (see \c include/wx/json_defs.h):

\code
  wxJSON_NO_64BIT_INT
\endcode

You can check whether ot not 64-bits support is enabled in the wxJSON library,
by checking if the wxJSON_64BIT_INT macro is defined
 

\subsection json_internals_integer_asis The IsXxxxxxx() and AsXxxxxxx() functions

You can get the type of a JSON value object by calling the \c IsXxxxxx()
functions where \c Xxxxxx is the type.
For example, to know if a JSON value object contains an integer value,
you call the \c wxJSONValue::IsInt() memberfunction.
Note that the function only returns TRUE if the stored value is of
type wxJSONTYPE_INT regardless whether or not the stored value
may also be represented as an unsigned integer.
Example:

\code
 wxJSONValue value(100);
 bool r = value.IsInt();        // return TRUE
      r = value.IsUInt();       // return FALSE
\endcode

On the other hand, the \b AsXxxxxx functions return the value as the
specified type, without checking if the stored value is actually
of the same type as the one wanted.
In other words, if a JSON value contains a signed integer which
value is -1, the user can get the value as an unsigned int.
Example:

\code
 wxJSONValue value(-1);
 int i       = value.AsInt();        // return -1
 unsigned ui = value.AsUInt();       // return 4294967295
\endcode

Also note that the \b Is(U)Int32/64 memberfunctions checks that the
stored integer fits in the integer storage specified in the 
memberfunction's name but you can still get the integer as another
(compatible) type.
For example, if an integer fits in 32-bits storage, the \c Is(U)Int64
memberfunction returns FALSE but you can still get the value as a
64-bit integer:

\code
 wxJSONValue value( 10000 );
 bool r      = value.IsInt64();        // return FALSE
 wxInt64 i64 = value.AsInt64();        // perfectly legal
\endcode

To know more about the return values of the \b IsXxxxxx and the \b AsXxxxxx
memberfunctions in 64-bits platforms, see the \c Test55() function in the
\c samples/test13.cpp source file.
The test function calls all the mentioned memberfunctions for several signed and
unsigned integers: results are commented.


\section json_internals_array The array of values.

An object of this type holds an array of \c wxJSONValue objects.
This means that you can have an array of integers, doubles,
strings, arrays and key/value maps, too
Moreover, the array can contain all these types. In other
words, the first element can be an integer, the second element
is another array, and the third one a key/value map.

The type is implemented using a \b wxObjArray class which stores
\c wxJSONValue objects.
The declaration of this type follows the wxWidget's container
classes declaration for arrays of objects:

\code
  class wxJSONValue;
  WX_DECLARE_OBJARRAY( wxJSONValue, wxJSONInternalArray )
\endcode

Note that the name of the type contains the word \e internal.
This means that the type is used internally by the wxJSONValue
class and should not be used by the application.
However, the class's API defines a member function that can
be used to get the internal array type:

\code
  const wxJSONInternalArray* AsArray() const;
\endcode

which returns the pointer of the array, stored in the
\c wxJSONValue::m_value.m_valArray data member.
There is no need for the application to access the internal
representation of the JSON array-type.
Use the wxJSONValue::Item, wxJSONValue::ItemAt and the
subscript operator for retreiving array's values.


\section json_internals_map The map of key/value pairs.

An object of this type is a map of key / value pairs where
the \b key is a string and the value is a wxJSONValue object:
it can hold bools, integers, strings, arrays and key/value maps,
too.

This type is implemented using the \b wxHashMap class which is
a simple, type-safe, and reasonably efficient hash map class
whose interface is a subset of the interface of STL containers.

The definition of the hashmap for wxJSONValue objects is as
follows:

\code
  WX_DECLARE_STRING_HASH_MAP( wxJSONValue, wxJSONInternalMap );
\endcode

Note that the name of the type contains the word \e internal.
This means that the type is used internally by the wxJSONvalue
class and should not be used by the application.
However, the wxJSONValue API defines a member function that can
be used to get this object:

\code
  const wxJSONInternalMap* AsMap() const;
\endcode

There is no need for the application to access the internal
representation of the JSON hashmap-type.
Use the wxJSONValue::Item(const wxString&), wxJSONValue::ItemAt
and the subscript operator for retreiving hashmap's values.


\section json_internals_compare The comparison function and operator

You may have noticed that the wxJSONValue class does not define a
comparison operator (the \b operator==() function).
This is not a forgetfullness but a precise design choice
because comparing wxJSON Value objects may be time-consuming 
and the meaning of \b equal is not applicable to JSON objects.
Consider the following two JSON objects:

\code
 // first object
 {
   "font" : {
     "size" = 12,
     "face" = "Arial",
     "bold" = true
   }
 }

 // second object
 {
   "font" : {
     "face" = "Arial",
     "bold" = true
     "size" = 12,
   }
 }
\endcode

You have to note that the two objects are not \b equal because the
order of the key/value pairs is not the same.
Althrough, the values that the two objects contain are \b the
\b same.

For this reason the wxJSONValue class does not define the
comparison operator but a similar function: the \c wxJSONValue::IsSameAs()
which returns TRUE if the two objects contain the same values
even if they are not in the same order: this applies for both
key/value maps and for arrays.

The comparison function is much time-consuming: for key/value
maps, the function first compares the number of elements in the
two objects and, if it is equal, for every key in the first
object it searches the second object and compares the values.

The job of comparing arrays is even worse: the comparison function
has to first compare the number of elements then, because the order
of the elements is unimportant, for each element in the first 
array the function iterates through all elements in the second
array searching for a matching element.

If the two objects are very complex, the comparison function
is very slow and you are discouraged to use it unless it is
strictly necessary.
I have defined this function only for debugging purposes.

\subsection json_internals_compare_convert Comparing different types

A problem in the interpretation of \b IsSameAs arise when comparing
different types that can be converted or promoted to another type.
Consider the two following JSON values:

\code
  wxJSONValue v1( 100 );
  wxJSONValue v2( 100.0 );
  bool r = v1.IsSameAs( v2 );  // should return TRUE
\endcode

The above values will be stored as different types: the first
as an integer and the second as a double but they are, in
fact, \b the \b same value and the function should
return TRUE.
Until the release 0.2.1 included, the wxJSON library had a
bug that cause the \c IsSameAs() function to return FALSE in
the above example.
This was due to the fact that the function first compared the
types and if they differ, FALSE was immediatly returned without
trying a type conversion.

Starting from release 0.2.2, this bug was fixed and the
wxJSONValue::IsSameAs() function now correctly compares compatible types:
by now, they only are the numeric types.
In other words, a string that contains the same value as a
numeric one is not the same.
Example:
\code
  wxJSONValue v1( 100 );
  wxJSONValue v2( _T("100"));
  bool r = v1.IsSameAs( v2 );  // returns FALSE
\endcode

The comparison function compares different numeric types
by promoting them to \b double an then comparing the double
values.
In this way the function correctly handles this situation:

\code
  wxJSONValue v1( -1 );            // this is -1
  wxJSONValue v2( (unsigned) -1);  // this is 4.294.967.296
  bool r = v1.IsSameAs( v2 );      // returns FALSE
\endcode


\section json_multiline_string The multiline string 

This feature allows a JSON string to be splitted in two or more lines
in the input JSON test:

\code
 {
    "copyright" : "This library is distributed\n"
                  "under the GNU Public License\n"
                  "(C) 2007 XYZ Software"
 }
\endcode

It is much more readable by humans because the \e new-line characters
contained in the value string are enforced by splitting the string into three lines.
The wxJSONReader allows this but reports a \e warning if the parser
was not constructed usign the wxJSONREADER_STRICT flag.
If \b strict is used, strings cannot be splitted.

In order to get this feature, the parser concatenates strings if a comma
character is not found between them. 
Note that only strings can be splitted into more than one line: numbers
and literals cannot be splitted.

The drawback is that this feature is error-prone. Consider the following
example:
\code
  {
    "seasons" :  [
      "spring",
      "summer"
      "autumn",
      "winter"
     ]
  }
\endcode

The array has four elements but I forgot the comma character between the
second and the third element.
What I get in this case is a three-elements array where the second element
is the concatenation of the two strings "summer" and "autumn" which is not
what I wanted.
Worse, the parser does not consider this an error: only a warning is
reported.

For this reason, I am not sure that this feature is really a feature:
maybe it will be dropped in next versions of the wxJSON library.


\section json_comment C/C++ comments in JSON text 

Starting with release 0.2, the wxJSON library recognizes and stores
C/C++ comments in JSON value objects.
See \ref wxjson_comments for a detailed implementation.




\section json_symbols Symbols used to customize the library's behaviuor

In this section you find the description of all symbols used to
customize the wxJSON's library behaviuor.
All those symbols are defined in the \c include/wx/json_defs.h source
file:

\code
wxJSON_MAJOR
wxJSON_MINOR
wxJSON_RELEASE
\endcode

The three macros are set equal to the major, minor and release version
numbers. To more info on the versioning scheme of wxJSON see the
VERSION text file in the top-level directory.


\code
WXJSON_USE_VALUE_COUNTER
\endcode

The above macro is used by the author for debugging purposes. If defined,
it causes the wxJSONValue object to use a progressive counter each time a
new object is created.
The macro is not defined by default.

\code
wxJSON_USE_UNICODE
\endcode

The above macro is defined if the library is being built in Unicode
mode.
In ANSI builds the macro is not defined.
Note that the macro should not be set by the user by automatically
by the compiler: in fact, the macro is defined if and only if
wxUSE_UNICODE == 1 which is set by \b wxWidgets itself.


*/



