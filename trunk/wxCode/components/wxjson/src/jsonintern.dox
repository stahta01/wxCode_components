
/*! \page pg_json_internals wxJSON internals


\li \ref json_internals_intro
\li \ref json_internals_cow
\li \ref json_internals_cstring
\li \ref json_internals_integer
\li \ref json_internals_array
\li \ref json_internals_map.
\li \ref json_internals_compare
\li \ref json_multiline_string
\li \ref json_comment
\li \ref json_symbols





\section json_internals_intro Introduction

The wxJSONValue class is much like a \b variant type which can hold
various types (see the documentation of the wxWidgets' \b wxVariant class).
The JSON value class is a bit different from wxVariant because it cannot hold
whatever type you want but only the following:

\li a NULL value
\li a signed integer
\li an unsigned integer
\li a double
\li a boolean
\li a C string
\li a wxString object
\li an array of wxJSONValue objects
\li an map of key/value pairs where the \e key is a wxString and the \e value
	can be any wxJSONValue object.

The type of the JSON value contained in a wxJSONValue object is an enumerated
constant of type wxJSONType.
Starting from version 0.5 the \b wxJSON library supports 64-bits integers
which introduced new JSON types. For more info see \ref json_internals_integer.

There is no need to specify the type of a wxJSONValue object: it is
automatically set when you construct the object or when a value is
assigned to it. For example:

\code
 wxJSONValue v;            // a 'null' value
 wxJSONValue v1( 10 );     // signed integer type
 wxJSONValue v2( 12.90);   // double type
 v1 = "some string";       // now 'v1' is of type string

 wxJSONValue v3;           // a 'null' value
 v3.Append( 10 );          // 'v3' is now of type wxJSONTYPE_ARRAY
\endcode


The only exception to this is when you want to set the wxJSONTYPE_INVALID.
Note that you should cast the wxJSONTYPE_INVALID constant to a wxJSONType type
because some compilers may assume the constant value to be an \b int:

\code
 wxJSONValue value( (wxJSONType) wxJSONTYPE_INVALID );
\endcode


\par The wxJSONRefData structure

All data is stored in the wxJSONRefData class which is just like a
simple structure: the class does not define an interface for accessing
data: it only defines the data members and the ctors and dtor.
The interface is totally defined in the wxJSONValue class which, in
turn, does not contain any data (with the exception of the pointer to
referenced data). This organization lets we use the \e reference \e counting
tecnique (also known as \e copy-on-write) when copying wxJSONValue objects.

The data structure holds the type of the JSON value, the JSON value itself,
the comment lines, if any, etc. To know more about the individual data
member defined in the class see the documentation of wxJSONRefData.
The data structure holds data in two different modes:

\li in a \b union for primitive types
\li in data members for complex types such as strings, arrays and maps

The union is defined as follows:

\code
  union wxJSONValueHolder  {
    int              m_valInt;
    unsigned int     m_valUInt;
    short int        m_valShort;
    unsigned short   m_valUShort;
    long int         m_valLong;
    unsigned long    m_valULong;
    double           m_valDouble;
    const wxChar*    m_valCString;
    bool             m_valBool;

 #if defined( wxJSON_64BIT_INT )
    wxInt64          m_valInt64;
    wxUint64         m_valUInt64;
 #endif
  };
\endcode


 The wxJSONRefData structure also holds the three complex objects
 that represent the three JSON value types: strings, arrays and objects
 (this is referred to JSON objets, not C++ class's instances):

\code
    wxString             m_valString;
    wxJSONInternalArray  m_valArray;
    wxJSONInternalMap    m_valMap;
\endcode

Note that primitive types are stored in a union and not in a structure:
this means that when you store a value in one of the data member, all
other are also affected.
I will explain more clearly with an example:

integers are stored using the most wide storage size; (unsigned) \b long \b int by default
and \b wx(U)Int64 on platforms that support 64-bits integers.
(to know more about 64-bits integer support read \ref json_internals_integer).
So if you store a \b int data type of value -1, all other data member will
get a value that depends on the data type stored.
Below you find an hardcopy of the memory dump of a JSON value object which
was assigned the integer value of -1:


<img src="images/intern01.png">

A value of -1 is stored as all binary '1' in the union but
the value returned by the wxJSONValue class depends on the type you want.
In other words, if you get the value as an integer you get -1 but if you
get the value as an \b unsigned integer you get different values depending
on the size of the requested type.
Also note that when the same value is returned as a double, the
wxJSONValue::AsDouble() function does not promote the \b int to a \b double:
the function just returns the bits as they are stored and interpreted as a
double thus returning a \e NaN.


\section json_internals_cow wxJSON internals: reference counting


Starting from version 0.4.0 the internal representation of a JSON value
has totally changed because of the implementation of the \e reference
\e counting tecnique also known as \e copy-on-write.
Now the wxJSONValue class does not actually contain any data: every
instance of this class holds a pointer to the actual data structure
defined in the wxJSONRefData class.
The structure contains a special data member that counts the number
of instances of wxJSONValue objects that share the data.

If you look at the example memory dump seen above, you will note the
\c wxJSONValue::m_refData data member that points to the actual
data structure and the \c wxJSONRefData::m_refCount data member that counts
how many JSON value objects share the data structure (one, in the example).

Reference counting is very simple: if you copy an instance of a wxJSONValue
object, the data contained in the wxJSONRefData structure is not
really copied but, instead, it is shared by the two JSON value objects
which data pointer points to the same memory area.
Here is an example:

\code
  wxJSONValue v1( 12 );
  wxJSONvalue v2( v1 );
\endcode

<img src="images/cow02.png">


Reference counting is implemented in many wxWidget's classes such as
wxBitmap, wxImage, etc but the wxJSONValue class is a bit different
because objects of this class may contain other wxJSONValue objects and
they can be nested to a virtually infinite level.
This cause references to not being propagated in the hierarchy.
Also, because values are accessed using the subscript operators -
which are \b non-const functions - COW for wxJSONValue objects is not as
efficient as we may expect.

In the following paragraphs I try to explain what happens when you
make a copy of a wxJSONValue and then call some non-const functions
on one of the two instances.




\subsection json_internals_cow_array Making a copy of an array type.

In the following example I create an array type and set a value to the
fourth element.
The subscript operator automatically creates the first for elements
and initializes them to a \b null value.
Then, the integer value is assigned to the fourth element by the
assignment operator.
Note that the first three array's element share the same data: this
is because the subscript operator automatically creates all instances
of the items until the requested index.
Needed items are created by copying (using COW) a temporary NULL
JSON value:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
\endcode

<img src="images/cow08.png">

Writing the value to a JSON text document we get the following:

\code
 [
    null,
    null,
    null,
    12
 ]
\endcode

Now copy the \b v1 JSON value to a \b v3 value.
Note that the root JSON data structure is shared by the two instances.



\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v3(v1);   // make a copy of 'v1'
\endcode

<img src="images/cow09.png">



We already noted that the three \b null values in the array share the same data
structure but because the root value is shared we only have 
a reference count of THREE for the NULL values.
In fact, the data is shared by SIX JSON value objects: 3 items in \b v1 plus
3 items in \b v3 (six values in total) but as the parent object is shared,
the wxJSONRefData::m_refCount data member only counts 3 shares.


\subsection json_internals_cow_write Writing to a shared data


\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v3(v1);   // makes a copy of 'v1'

  v3[1] = 2;            // change the value of the second array's element
\endcode

When we change a value of an array's element we would expect that a real
copy of only that array's element is done and it is assigned the new
value.

We are wrong. In fact, the wxJSONValue object makes a copy of the
whole root object \b v3. Why?
The answer is simple: the first impression is that the assignment operator
is called for the second array element of \b v3 and this would cause a
real copy of that array's element.
In reality, \b before calling the \b operator= memberfunction the
code fragment seen above must return a reference to the second
element of \b v3's array.
This reference is returned by the \b operator[] (the subscript operator)
which is itself a \b non-const memberfunction.
So, the subscript operator of the root value object makes a real copy
of the referenced data.
All array's elements are copied from \b v1's instance to \b v3.
You may notice from the memory dump that the copy of elements is
not a real copy but it uses COW.
Below you find the memory dump of the two object after we had changed
one array's element.
As you can see, each root value has now an exclusive copy of the
array:

<img src="images/cow10.png">




In order to avoid the copy of the top-level array type we have had to
use a \e const member function to access the second array's element.
Note that we cannot use the wxJSONValue::ItemAt() function because
this function returns a copy of the data not a reference to it:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  // does not work!!! what we do is to change a temporary copy
  // of the second array's element
  v2.ItemAt( 1 ) = "value changed";
\endcode


The only suitable function is the wxJSONValue::Find() function which is,
unfortunately, protected so it cannot be called from outside the
class.

Another drawback of using non-const subscript operators is that 
the copy operation is done also when we do not write to the
JSON value object but also when we read from it.
This is an example:

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  int i = v1[3].AsInt();   // read from 'v1'
\endcode

Because the \b operator[] memberfunction is non-const, the read 
operation causes the wxJSONValue class to make an exclusive copy
of shared data even when the access to the value is only for
read purposes.
The good news is that we can use wxJSONValue::ItemAt() in this case
thus avoiding the copy operation of the shared data (
OK, tested see \c samples/test11.cpp function \c Test51() )

\code
  wxJSONValue v1;
  v1[3] = 12;           // set the value of the fourth item
  wxJSONValue v2(v1);   // makes a copy of 'v1'

  int i = v1.ItemAt( 3 ).AsInt();
\endcode

The problem is that we can use \c ItemAt() for only one level in
the JSON value's hierarchy.

So is COW totally useless? No, it is not!

Even when using subscripts operators, the real copy of shared data
is done only until the parent of the requested level: every
other JSON value objects of the same level and of inferior
levels are not really copied: COW is used for all of them.
In the following image you see that in the above example of a
four element's array, the JSON array value \b v1 is copied to
\b v3 but the individual items are not really copied because
3 items of \b v1 and 2 items of \b v3 refer to the same
referenced data (the NULL value):

<img src="images/cow11.png">

In this example, the array's items are NULL values, thus the
time that was saved in the COW in not really much but remember
that an array's item may contain another array which may contain
one or more key/value hashmaps, which may contain one or more
array which .... and so on.



\section json_internals_cstring wxJSON internals: the C string type

\code
  wxJSONValue( const wxChar* str );
  wxJSONValue( const wxString& str );
\endcode


You may ask yourself why there are 2 different constructors for strings.
For convenience, you may think, in order to save an implicit conversion
from \b const \b wxChar* to \b wxString.
The answer is: NO. The two constructors store the string in a very
different way.

Both ctors store strings and they could be
stored just as \b wxString objects. In fact, this is the default
behaviour of the class if the \c WXJSON_USE_CSTRING macro is not defined.

If this macro is defined, however, the first ctor stores the pointer in the
\c wxJSONRefData structure assuming that the string is statically
allocated and it does NOT copy the string.
This behaviour saves a string's copy which can be time-consuming
but, on the other hand, you must be sure that the pointed-to
buffer is not freed / deallocated for the lifetime of the wxJSONValue
object (this is always true for static strings).
The following code fragment is an example on how to use the static
string type:

\code
  wxJSONValue aString( _T("This is a static string"));
\endcode

The code above is correct, because the pointed-to string is really
statically allocated (and, on most platforms, static strings are allocated
in the code segment so that they cannot be changed for the lifetime of the
application).

The following code is not correct and it would probably result
in a SEGFAULT when you try to access the wxJSONValue data.
The problem is that the string is constructed on the stack which
will be deallocated when the function returns.
So, the returned JSON object contains a pointer to a deallocated
memory area.

\code
  // Example 1
  wxJSONValue MyFunction()
  {
    char buffer[128];
    snprintf( buffer, 128, "This is a string constructed on the stack");
    wxJSONValue aString( buffer );
    return aString;
  }
\endcode

The code above should be written as follows:

\code
  // Example 2
  wxJSONValue MyFunction()
  {
    char buffer[128];
    snprintf( buffer, 128, "This is a string constructed on the stack");
    wxJSONValue aString( wxString( buffer));
    return aString;
  }
\endcode

Now it is correct because the \b wxString object holds a \b copy of the
\c buffer memory area.
Note that if the \c WXJSON_USE_CSTRING macro is not defined, there is no need
to actually construct a temporary \b wxString object in order to force the
wxJSONValue class to create an instance of the wxString object: it is
automaticlly created by the wxJSONValue( const wxChar*) ctor.
This mean that you can use use the code in \b Example \b 1 without
worry about C-strings.
By default, the wxJSON_USE_CSTRING macro is \b not defined.

If your application uses many static strings that never changes,
you can save time by defining the symbol when compiling the wxJSON library

\b NOTES: the static C-string type value is, probably, useless and, in
fact, it is never used in wxJSONValue by default.
The C string value is useless because the only reason for using it
is speed: time is saved when no string-copy operation is performed.
But the \b wxString object uses \e copy-on-write to avoid unnecessary
copies so it is much more wisely (and SAFE) to never use C-strings.


\section json_internals_integer 64-bits and 32-bits integers

Starting from version 0.5, the \e wxJSON library supports 64-bits
integers but only on those platforms that have native support for
64-bits integers such as, for example, Win32 and GNU/Linux.

Starting from version 1.0 the wxJSONValue also handles
\b long \b int and \b short \b int data types.

By default, the library checks if the \b wxLongLong_t macro is
defined by \b wxWidgets and, if it is, the library enables 64-bits
integer support.
The \b wxLongLong_t macro is the wxWidget's platform independent
data type for representing a 64-bits integer and it is defined
by the GUI framework as a placeholder for the underlying
compiler / platform specific data type: \b __int64 on Windows
and \b long \b long on GNU/Linux systems.
To know more about the wxWidget's 64-bits integer stuff read the
documentation of the \b wxLongLong class.
If the system / platform do not support 64-bits integers, integer values
are stored in a:

 \li (unsigned) \b long \b int (32-bit) data type in wxJSON versions 1.0 and above
 \li (unsigned) \b int data type in all 0.x versions.


The user can disable 64-bits integer support by defining the:

\code
  wxJSON_NO_64BIT_INT
\endcode

macro in the \c include/wx/json_defs.h header file (just uncomment the
line where the macro is defined).

All integer values are stored in the widest storage size: \b wx(U)int64
or \b long \b int depending the platform.
The \c m_type data member of the JSON value is set to the generic integer
type: wxJSONTYPE_INT or wxJSONTYPE_UINT regardless its size: in other
words, no matter the type of the original value:
the only thing that matters is the sign of the value: signed or unsigned.

\code
  wxJSONValue i( 100)               // an int
  wxJSONValue l( (short) 100)       // a short int
  wxJSONValue l( (long) 100)        // a long int
  wxJSONvalue i64( (wxInt64) 100 ); // a long long int
\endcode

All the above integer values are stored in the \c wxJSONValueHolder::m_valInt64
or in the \c wxJSONValueHolder::m_valLong data member.
The JSON value type is set to wxJSONTYPE_INT for all cases.
As the storage area of all primitive types is the same (it is an union) it is
very easy to return an integer value in different sizes provided that the
requested integer type has sufficient bits to store the value.

How can the user know the storage needs of a integer data type?
First of all you have to ask yourself if you really need to know this
information.
In other words, if your application only uses the \b int data type (for integers) and
it only reads its own JSON data file, it is improbable that an integer
value stored in the JSON value class will hold other than an \b int.
On the other hand, if your application communicate with other applications
over a network connection, it may be possible that the JSON value class
holds integers which are so large that they cannot fit in a simple \b int
data type.

In order to know the storage needs of the value stored in the class you call
the \c wxJSONType::GetType() function which returns different constants
depending on the weight of the numeric value:


\li \b wxJSONTYPE_SHORT: the value is of type wxJSONVALUE_INT and it fits in a \b short \b int
\li \b wxJSONTYPE_USHORT: the value is of type wxJSONVALUE_UINT and it fits in a \b unsigned
	\b short
\li \b wxJSONTYPE_LONG: the value is of type wxJSONVALUE_INT and it fits in a \b long \b int
	but it is too large for \b short \b int.
\li \b wxJSONTYPE_ULONG: the value is of type wxJSONVALUE_UINT and it fits in a \b unsigned
	\b long but it is too large for \b unsigned \b short.
\li \b wxJSONTYPE_INT64: the value is of type wxJSONVALUE_INT and it is so large that it needs 64-bits.
\li \b wxJSONTYPE_UINT64: the value is of type wxJSONVALUE_UINT and it is so large that
	it needs 64-bits.

The \b GetType() function relies on the definition of the SHORT_MAX, SHORT_MIN, USHORT_MAX, 
LONG_MAX, LONG_MIN, ULONG_MAX, macros to check if the value fits in a particular data type.
If the macros are not defined (I do not know if this could happen), the wxJSON
library defines them by itself according to the rules of the C99 standard
(see the \c include/wx/json_defs.h header file):

\code
   C99 type      width (bits)         limits
   --------      ------------         ------
   short            16                -32.768 .. +32.767
   ushort           16                0 .. 65.535
   long             32                -2.147.483.648 .. +2.147.483.647
   ulong            32                0 .. +4.294.967.295
\endcode

Note that the C99 standard only defines the \e minimum width of these types;
in addition, the C++ language does not define a minimum size for these integer
types.

Also note that the wxJSONValue::GetType() function never returns wxJSONTYPE_INT.
This is because the \b int data type has a variable bit-width that depends on
the platform: on Win32 and GNU/Linux, the \b int type is the same as \b long
(32 bits wide) but on other platforms it may be only 16 because the minimum width
of \b int is 16 in the C99 standard.
For this reason, it is always a good practice to never use \b int in C/C++ 
programming language but the \b long data type which ensures 32-bits integers.

The wxJSONValue class lets you use \b int as the returned data type because it
defines the \b Is(U)Int memberfunction which returns the correct result depending
on the definition of the INT_MAX, INT_MIN and UINT_MAX macros.



\subsection json_internals_integer_is The IsXxxxx() functions

The wxJSONValue class also defines functions of the form \b IsXxxxxx() to know
the storage needs of an integer type:

\par Signed integers
\li \c IsInt()
\li \c IsShort()
\li \c IsLong()
\li \c IsInt64()

\par Unsigned integers
\li \c IsUInt()
\li \c IsUShort()
\li \c IsULong()
\li \c IsUInt64()


Note that in version 1.x those functions behaves differently than in versions 0.x
Now all functions return TRUE if the value can be stored in the desired type, with
respect to the sign of the value.

In 0.x versions only one of the 8 functions returned TRUE: the one that match
the sign of the stored value AND the storage needs.
In other words, if a value contains the signed integer value of 100, the
\b IsInt() function returns TRUE while the \b isInt64() returns FALSE.
This is wrong because the value fits in a 64-bits integer.
In the new 1.0 version, all functions related to signed integer return TRUE if
the value contained is 100.

All 64-bits integer memberfunctions are only available if
the platform on which runs your application natively supports
64-bits integers.
This is in constrast with the \b wxLongLong class which is also
available on 32-bits platforms.

If your system natively supports 64-bits integers but you do not want
to include this feature in the \b wxJSON library, you can define the
following macro when compiling the library (see \c include/wx/json_defs.h):

\code
  wxJSON_NO_64BIT_INT
\endcode

You can check whether or not 64-bits support is enabled in the wxJSON library,
by checking if the wxJSON_64BIT_INT macro is defined.
 


\subsection json_internals_integer_asis The IsXxxxxxx() and AsXxxxxxx() functions

You can get the type of a JSON value object by calling the \c IsXxxxxx()
functions where \c Xxxxxx is the type.
For example, to know if a JSON value object contains an integer value,
you call the \c wxJSONValue::IsInt() memberfunction.
Note that the function returns TRUE if the stored value is of
type wxJSONTYPE_INT and it fits in a \b int data type.
Example:

\code
 wxJSONValue value(100);
 bool r = value.IsInt();        // return TRUE
      r = value.IsShort();      // return TRUE
      r = value.IsUInt();       // return FALSE (value is signed)
      r = value.IsLong();       // return TRUE

 value = (wxInt64) LONG_MAX + 1;  // needs 64-bits integer support

      r = value.IsInt64();        // return TRUE
      r = value.IsLong();         // return FALSE
      r = value.IsInt();          // return FALSE 
\endcode

On the other hand, the \b AsXxxxxx functions return the value as the
specified type, without checking if the stored value is actually
of the same type as the one wanted.
In other words, the AsXxxxxx() functions just returns the bit pattern
stored in the union interpreting those bits as the desired type.

Example:

\code
 wxJSONValue value(-1);
 int i             = value.AsLong();    // return -1
 unsigned int ui   = value.AsULong();   // return 4294967295
 unsigned short us = value.AsUShort();  // return 65535
\endcode

Note that all primitive types are stored in a \b union so you can get
the value of a primitive type as the one you want.
Also note that the \c AsXxxxxx() function does not check that the
value is compatible with the one you want.
For example:

\code
  wxJSONValue value( 10000 );
  wxChar* ch = value.AsCString();    // returns 10000 which is garbage
\endcode

However, in debug builds, all AsXxxxxx() functions wxASSERT that the
type of the stored value is compatible with the one you want.
In the previuos example, an ASSERTION failure occurs in the \c AsCString()
function because the returned value is, surely, garbage.


To know more about the return values of the \b IsXxxxxx and the \b AsXxxxxx
memberfunctions in 64-bits platforms, see the \c Test55() function in the
\c samples/test13.cpp source file.
The test function calls all the mentioned memberfunctions for several signed and
unsigned integers: results are commented.


\subsection json_internals_integer_read Reading numeric values from JSON text.

If 64-bits support is enabled in the wxJSON library, reading values
from JSON text may have different results.
If a numeric value is too large for 32-bits integer storage, it will be
stored as a double data type in versions 0.4 and previous ones but it may be
stored as and integer if it fits in a 64-bit integer storage.

When the wxJSON parser reads a token that start with a digit or with a
minus or plus sign, it assumes that the value read is a number and
it tries to convert it to:

\li first tries signed integer conversion
\li if the number does not fit, tries unsigned conversion
\li if the number does not fit, tries double conversion
\li if unsuccessfull, an error is reported


Note that if 64-bits storage is enabled, the wxJSON parser, does not try to
convert numeric tokens in a 32-bits integer but immediatly tries 64-bits
storage.
This has the conseguence that numeric values that are between
INT_MAX + 1 and UINT_MAX are stored as signed integers in a 64-bits environment
and as unsigned integers in a 32-bits environment.

Examples:

\code
  {
    // if 64 bits integer is not enabled
    100         // read as a signed long integer
    2147483647  // INT_MAX: read as a signed long integer
    2147483648  // INT_MAX + 1: read as a unsigned long

   -2147483648  // INT_MIN: read as a signed long integer
    4294967295  // UINT_MAX: read as a unsigned long integer

    4294967296  // UINT_MAX: read as a double

    // if 64-bits integer is enabled
    4294967295  // UINT_MAX: read as a signed wxInt64
    4294967296  // UINT_MAX: read as a signed wxInt64
  }
\endcode

Also note that if a number is between INT64_MIN and INT64_MAX (or
LONG_MIN and LONG_MAX, depending on the platform) it is always
read as a signed integer regardless its original type.
You can use a special writer's flag in order to force the wxJSON
library to recognize unsigned JSON values written to JSON text.
See wxjson_tutorial_style_unsigned for more info.


\section json_internals_array The array of values.

An object of this type holds an array of \c wxJSONValue objects.
This means that you can have an array of integers, doubles,
strings, arrays and key/value maps, too
Moreover, the array can contain all these types. In other
words, the first element can be an integer, the second element
is another array, and the third one a key/value map.

The type is implemented using a \b wxObjArray class which stores
\c wxJSONValue objects.
The declaration of this type follows the wxWidget's container
classes declaration for arrays of objects:

\code
  class wxJSONValue;
  WX_DECLARE_OBJARRAY( wxJSONValue, wxJSONInternalArray )
\endcode

Note that the name of the type contains the word \e internal.
This means that the type is used internally by the wxJSONValue
class and should not be used by the application.
However, the class's API defines a member function that can
be used to get the internal array type:

\code
  const wxJSONInternalArray* AsArray() const;
\endcode

which returns the pointer of the array, stored in the
\c wxJSONValue::m_value.m_valArray data member.
There is no need for the application to access the internal
representation of the JSON array-type.
Use the wxJSONValue::Item, wxJSONValue::ItemAt and the
subscript operator for retreiving array's values.


\section json_internals_map The map of key/value pairs.

An object of this type is a map of key / value pairs where
the \b key is a string and the value is a wxJSONValue object:
it can hold bools, integers, strings, arrays and key/value maps,
too.

This type is implemented using the \b wxHashMap class which is
a simple, type-safe, and reasonably efficient hash map class
whose interface is a subset of the interface of STL containers.

The definition of the hashmap for wxJSONValue objects is as
follows:

\code
  WX_DECLARE_STRING_HASH_MAP( wxJSONValue, wxJSONInternalMap );
\endcode

Note that the name of the type contains the word \e internal.
This means that the type is used internally by the wxJSONvalue
class and should not be used by the application.
However, the wxJSONValue API defines a member function that can
be used to get this object:

\code
  const wxJSONInternalMap* AsMap() const;
\endcode

There is no need for the application to access the internal
representation of the JSON hashmap-type.
Use the wxJSONValue::Item(const wxString&), wxJSONValue::ItemAt
and the subscript operator for retreiving hashmap's values.


\section json_internals_compare The comparison function and operator

You may have noticed that the wxJSONValue class does not define a
comparison operator (the \b operator==() function).
This is not a forgetfullness but a precise design choice
because comparing wxJSON Value objects may be time-consuming 
and the meaning of \b equal is not applicable to JSON objects.
Consider the following two JSON objects:

\code
 // first object
 {
   "font" : {
     "size" = 12,
     "face" = "Arial",
     "bold" = true
   }
 }

 // second object
 {
   "font" : {
     "face" = "Arial",
     "bold" = true
     "size" = 12,
   }
 }
\endcode

You have to note that the two objects are not \b equal because the
order of the key/value pairs is not the same.
Althrough, the values that the two objects contain are \b the
\b same.

For this reason the wxJSONValue class does not define the
comparison operator but a similar function: the \c wxJSONValue::IsSameAs()
which returns TRUE if the two objects contain the same values
even if they are not in the same order: this applies for both
key/value maps and for arrays.

The comparison function is much time-consuming: for key/value
maps, the function first compares the number of elements in the
two objects and, if it is equal, for every key in the first
object it searches the second object and compares the values.

The job of comparing arrays is even worse: the comparison function
has to first compare the number of elements then, because the order
of the elements is unimportant, for each element in the first 
array the function iterates through all elements in the second
array searching for a matching element.

If the two objects are very complex, the comparison function
is very slow and you are discouraged to use it unless it is
strictly necessary.
I have defined this function only for debugging purposes.

\subsection json_internals_compare_convert Comparing different types

A problem in the interpretation of \b IsSameAs arise when comparing
different types that can be converted or promoted to another type.
Consider the two following JSON values:

\code
  wxJSONValue v1( 100 );
  wxJSONValue v2( 100.0 );
  bool r = v1.IsSameAs( v2 );  // should return TRUE
\endcode

The above values will be stored as different types: the first
as an integer and the second as a double but they are, in
fact, \b the \b same value and the function should
return TRUE.
Until the release 0.2.1 included, the wxJSON library had a
bug that cause the \c IsSameAs() function to return FALSE in
the above example.
This was due to the fact that the function first compared the
types and if they differ, FALSE was immediatly returned without
trying a type conversion.

Starting from release 0.2.2, this bug was fixed and the
wxJSONValue::IsSameAs() function now correctly compares compatible types:
by now, they only are the numeric types.
In other words, a string that contains the same value as a
numeric one is not the same.
Example:
\code
  wxJSONValue v1( 100 );
  wxJSONValue v2( _T("100"));
  bool r = v1.IsSameAs( v2 );  // returns FALSE
\endcode

The comparison function compares different numeric types
by promoting them to \b double an then comparing the double
values.
In this way the function correctly handles this situation:

\code
  wxJSONValue v1( -1 );            // this is -1
  wxJSONValue v2( (unsigned) -1);  // this is 4.294.967.296
  bool r = v1.IsSameAs( v2 );      // returns FALSE
\endcode


\section json_multiline_string The multiline string 

\b WARNING: this feature in old 0.x versions is a conseguence of an error
in the implementation or the wxJSONWriter's flags.
The feature is still usefull but its implementation had changed in the
writer class: no change is needed in the parser.

\par The old 0.x documentation

This feature allows a JSON string to be splitted in two or more lines
in the input JSON test:

\code
 {
    "copyright" : "This library is distributed\n"
                  "under the GNU Public License\n"
                  "(C) 2007 XYZ Software"
 }
\endcode

It is much more readable by humans because the \e new-line characters
contained in the value string are enforced by splitting the string into three lines.
The wxJSONReader allows this but reports a \e warning if the parser
was not constructed usign the wxJSONREADER_STRICT flag.
If \b strict is used, strings cannot be splitted.

In order to get this feature, the parser concatenates strings if a comma
character is not found between them. 
Note that only strings can be splitted into more than one line: numbers
and literals cannot be splitted.

The drawback is that this feature is error-prone. Consider the following
example:
\code
  {
    "seasons" :  [
      "spring",
      "summer"
      "autumn",
      "winter"
     ]
  }
\endcode

The array has four elements but I forgot the comma character between the
second and the third element.
What I get in this case is a three-elements array where the second element
is the concatenation of the two strings "summer" and "autumn" which is not
what I wanted.
Worse, the parser does not consider this an error: only a warning is
reported.

For this reason, I am not sure that this feature is really a feature:
maybe it will be dropped in next versions of the wxJSON library.

\par The actual documentation


I wrote the old documentation just for historycal purposes and for clarity:
it helps to understand why the feature was changed in 1.0 version.
First of all if you run the test #24 in the test application (see the
Test24() function in the \c samples/test6.cpp source file) you got
the following output:

\code
   "This is a multiline string\n"
      "this is line #2\n"
      "this is line #3"
\endcode

which is just as explained before and it seems good but it isn't.
The problem is that the LF character \b contained in the three strings
would have to break the line just before the close-quote characters
but this does not happen. The reason is that the LF character was not
acually a LF (0x0D) but the lowercase letter 'n'.
This is due to a implementation error in the \c wxJSONWriter::WriteStringValue()
function which contains a table of characters that have to be escaped and the
corresponding table of escape sequences.
Here is the old code:

\code
  // the characters that have to be escaped
  static const wxChar escapedChars[] = { 
	_T( '\"' ), // quotes 
	_T( '\\' ), // reverse solidus
	_T( '/' ),  // solidus
	_T( '\b' ), // backspace
	_T( '\f' ), // formfeed
	_T( '\n' ), // newline
	_T( '\r' ), // carriage-return
	_T( '\t' )  // horizontal tab
  };

  // the escape sequences that has to be written instead of the characters
  const wxString replaceChars[] = { 
	_T("\\\""),		// OK
	_T("\\\\"),		// OK
	_T("\\/"),		// OK
	_T("\\b"),		// should be "\\\b"
	_T("\\f"),		// should be "\\\f"
	_T("\\n"),		// should be "\\\n"
	_T("\\r"),		// should be "\\\r"
	_T("\\t")		// should be "\\\t"
  };
\endcode

As you can see, I forgot one ESC character so the escape sequence for a LF
character results in a ESCAPE character followed by a lowercase letter 'n'.

The conseguence is that the \e multiline string feature is good for the
parser but it is useless for the writer: there is no need to enforce a line-feed
character by adding another line-feed character: the string already results splitted.
If we add the line-feed after the close-quote character, the readibility
of the JSON text will be made worse.


\code
// the output without the MULTILINE string feature is more readable
// than using it: LF character are escaped.

"This is a multiline string\
this is line #2\
this is line #3"
\endcode


Nevertheless, the flag is still usefull in the JSON writer.
If a string value is very long, it would be nice to split it into two or
more lines provided that the string itself does not contain LF characters.
Consider the following example:

\code
  {
  	"key" : "A very long string value that cause the user to scroll horizontally in order to actually read the whole line"
  }
\endcode

It would be more readable if it was written as:

\code
  {
  	"key" : "A very long string value that cause the user to scroll"
		" horizontally in order to actually read the whole line"
  }
\endcode

The reader is already capable of reading multiline strings such as the one
seen above regardless they contain LF characters (escaped or not) just
specify the wxJSONREADER_MULTISTRING flag in its constructor.

For the writer, the wxJSONWRITER_SPLIT_STRING flag has changed its implementation:
strings are not splitted when a LF character is encontered but only if
the 75th column has reached in the output JSON text.
Note that the writer will split the string when a space character is encontered
so that a single word is not splitted in two lines.



\section json_comment C/C++ comments in JSON text 

Starting with release 0.2, the wxJSON library recognizes and stores
C/C++ comments in JSON value objects.
See \ref wxjson_comments for a detailed implementation.




*/



