<HTML>
<head><link rel=stylesheet type="text/css" href="wx.css">
<title>wxMidi</title></head>

<BODY BGCOLOR=#FFFFFF>
<FONT FACE="Arial, Lucida, Helvetica">

<a name="wxMidiDevice"/>
<H2>wxMidiDevice</H2>
The base interface for devices is wxMidiDevice. It is an abstract class with two derived classes:
<A href="#wxMidiInDevice">wxMidiInDevice</A> and <A href="#wxMidiOutDevice">wxMidiOutDevice</A><P>

A wxMidiDevice object represents a MIDI stream on which MIDI data traffic can be read or sent. All MIDI communication is achieved through a wxMidiDevice by using MIDI messages. Devices can be opened and closed, and they provide descriptions of themselves.<P>

MIDI messages are represented by the <A HREF="wxMidiMessage.htm#wxMidiMessage">wxMidiMessage</A> abstract class and are read and sent from/to the MIDI stream by using methods
<A href="#wxMidiInDeviceRead">Read</A> and 
<A href="#wxMidiOutDeviceWrite">Write</A>, respectively.<P>

For the most common output operations, such as note on or note off, there are specific methods implemented so that wxMidi user has not to build and send the appropriate messages. See: 
<A href="#wxMidiOutDeviceNoteOn">NoteOn</A>, 
<A href="#wxMidiOutDeviceNoteOff">NoteOff</A>,
<A href="#wxMidiOutDeviceProgramChange">ProgramChange</A>,
<A href="#wxMidiOutDeviceAllSoundsOff">AllSoundsOff</A>.<P>


<B><FONT COLOR="#FF0000">Derived from</FONT></B><P>
None<P>

<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A href="#wxMidiInDevice">wxMidiInDevice</A>,
<A href="#wxMidiOutDevice">wxMidiOutDevice</A>,
<A HREF="wxMidiMessage.htm#wxMidiMessage">wxMidiMessage</A>,
<A href="wxMidiSystem.htm#wxMidiSystem">wxMidiSytem</A>,
<A HREF="wxMidi.htm#wxMidiQuickStart">wxMidi quick start</A>
<P>

<B><FONT COLOR="#FF0000">Members</FONT></B><P>
<a href="#wxMidiDeviceConstr">wxMidiDevice::wxMidiDevice</a><BR>
<a href="#wxMidiDeviceDestr">wxMidiDevice::~wxMidiDevice</a><BR>
<a href="#wxMidiDeviceClose">wxMidiDevice::Close</a><BR>
<a href="#wxMidiDeviceDeviceName">wxMidiDevice::DeviceName</a><BR>
<a href="#wxMidiDeviceHasHostError">wxMidiDevice::HasHostError</a><BR>
<a href="#wxMidiDeviceInterfaceUsed">wxMidiDevice::InterfaceUsed</a><BR>
<a href="#wxMidiDeviceIsInputPort">wxMidiDevice::IsInputPort</a><BR>
<a href="#wxMidiDeviceIsOutputPort">wxMidiDevice::IsOutputPort</a><BR>
<P>


<!-- ======================================================================================= -->

<HR>
<A NAME="wxMidiDeviceConstr"></A>
<H3>wxMidiDevice::wxMidiDevice</H3>
<P>
<B></B> <B>wxMidiDevice</B>(<B>wxMidiDeviceID</B> <I>nDevice</I>)<P>
Constructor.<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>nDevice</I><UL>
The number of the device.  Device numbers (also referred as device IDs) range from 0 to
wxMidiSystem::CountDevices() - 1
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">See also:</FONT></B><P>
<a href="wxMidiSystem.htm#wxMidiSystemCountDevices">wxMidiSystem::CountDevices</a>
<P>


<HR>
<A NAME="wxMidiDeviceDestr"></A>
<H3>wxMidiDevice::~wxMidiDevice</H3>
<P>
<B></B> <B>~wxMidiDevice</B>()<P>
Destructor.<P>


<HR>
<a name="wxMidiDeviceClose"/>
<H3>wxMidiDevice::Close</H3>
<B>wxMidiError Close</B>();<P>

Closes a MIDI stream, flushing any pending messages. 
Any wxMidiDevice that is successfully opened should eventually be closed calling Close().<P>


<HR>
<a name="wxMidiDeviceDeviceName"/>
<H3>wxMidiDevice::DeviceName</H3>
<B>const wxString </B><B>DeviceName</B>()<P>

Returns a string containing the name of the MIDI device. For example "MPU-401 Compatible card".<P>


<HR>
<a name="wxMidiDeviceHasHostError"/>
<H3>wxMidiDevice::HasHostError</H3>
<B>int</B> <B>HasHostError</B>()<P>

Check if the wxMidiDevice has a pending host error to be reported.<P>

Normally, the application finds out about wxMidi errors through 
returned error codes, but some errors can occur asynchronously where the application does not explicitly call a function, and therefore cannot receive an error code.<P>

The client can test for a pending error using method HasHostError(). If true,
the error can be accessed and cleared by calling
<a href="wxMidiSystem.htm#wxMidiSystemGetErrorText">wxMidiSystem::GetErrorText</a>.
It is nor necessary to call HasHostError() as any pending error will be reported the next time the application  performs an explicit function call on the wxMidiDevice, i.e. an input or output operation.<P>


<HR>
<a name="wxMidiDeviceInterfaceUsed"/>
<H3>wxMidiDevice::InterfaceUsed</H3>
<B>const wxString InterfaceUsed</B>()<P>
Returns a string containing the name of the API used internally to implement MIDI communication. Examples
are 
"MMSystem", "DirectX", "ALSA", "OSS", etc. At present, the only Win32 interface
implemented is "MMSystem", the only Linux
interface is "ALSA", and the only Max OS X interface is "CoreMIDI".<P>


<HR>
<a name="wxMidiDeviceIsInputPort"/>
<H3>wxMidiDevice::IsInputPort</H3>
<B>bool IsInputPort</B>()<P>

Returns true if the device has input capabilities and then can be used as wxMidiInDevice.<P>

<HR>
<a name="wxMidiDeviceIsOutputPort"/>
<H3>wxMidiDevice::IsOutputPort</H3>
<B>bool IsOutputPort</B>()<P>
Returns true if the device has output  capabilities and then can be used as wxMidiOutDevice.<P>


<!-- ======================================================================================= -->


<HR>
<a name="wxMidiInDevice"/>
<H2>wxMidiInDevice</H2>
A wxMidiInDevice object represents a MIDI stream on which MIDI data traffic can be read.<P>

<B><FONT COLOR="#FF0000">Derived from</FONT></B><P>
<A href="#wxMidiDevice">wxMidiDevice</A><P>

<B><FONT COLOR="#FF0000">Members</FONT></B><P>
<A href="#wxMidiInDeviceConstr">wxMidiInDevice::wxMidiInDevice</A><BR>
<A href="#wxMidiInDeviceDestr">wxMidiInDevice::~wxMidiInDevice</A><BR>
<A href="#wxMidiInDeviceFlush">wxMidiInDevice::Flush</A><BR>
<A href="#wxMidiInDeviceOpen">wxMidiInDevice::Open</A><BR>
<A href="#wxMidiInDevicePoll">wxMidiInDevice::Poll</A><BR>
<A href="#wxMidiInDeviceRead">wxMidiInDevice::Read</A><BR>
<A href="#wxMidiInDeviceSetFilter">wxMidiInDevice::SetFilter</A><BR>
<A href="#wxMidiInDeviceSetChannelMask">wxMidiInDevice::SetChannelMask</A><BR>
<A href="#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A><BR>
<A href="#wxMidiInDeviceStopListening">wxMidiInDevice::StopListening</A><BR>


<HR>
<a name="wxMidiInDeviceConstr"/>
<H3>wxMidiInDevice::wxMidiInDevice</H3>
<B>wxMidiInDevice</B>(<B>wxMidiDeviceID </B><I>nDevice</I>)<P>

Constructor.<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>nDevice</I><UL>
The number of the device.  Device numbers (also referred as device IDs) range from 0 to
wxMidiSystem::CountDevices() - 1
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">See also:</FONT></B><P>
<a href="wxMidiSystem.htm#wxMidiSystemCountDevices">wxMidiSystem::CountDevices</a>
<P>


<HR>
<a name="wxMidiInDeviceDestr"/>
<H3>wxMidiInDevice::~wxMidiInDevice</H3>
~<B>wxMidiInDevice</B>()<P>

Destructor.<P>


<HR>
<a name="wxMidiInDeviceFlush"/>
<H3>wxMidiInDevice::Flush</H3>
<B>void Flush</B>()<P>
Discard any MIDI messages waiting to be read.<P>


<HR>
<a name="wxMidiInDeviceOpen"/>
<H3>wxMidiInDevice::Open</H3>
<B>wxMidiError Open</B>(<B>void </B>*<I>pDriverInfo </I>= NULL)<P>

Open the device, so that the device can be used.<P>

Upon success Open() returns zero (wxMIDI_NO_ERROR). If the open process fails a non-zero error code is returned.<P>

Any successfully opened device should eventually be closed
calling Close().<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pDriverInfo</I><UL>
pDriverInfo is a pointer to an optional driver specific data structure
containing additional information for device setup or handle processing.
pDriverInfo is never required for correct operation. If not used
pDriverInfo should be NULL.
</UL><P>


<HR>
<a name="wxMidiInDevicePoll"/>
<H3>wxMidiInDevice::Poll</H3>

wxMidiError Poll()<P>

Check if there is a received MIDI message waiting to be Read().  It returns TRUE if there are messages waiting, FALSE if not, or an error value if an error ocurred.<P>


<HR>
<a name="wxMidiInDeviceRead"/>
<H3>wxMidiInDevice::Read</H3>
<B>wxMidiMessage</B>* Read(<B>wxMidiError</B>* <I>pError</I>)<P>
    
Retrieves a received MIDI message and modifies value of variable pointed by pError to leave an error code. On success, a pointer to a MIDI message (either wxMIDIShortMessage or wxMidiSysExMessage) is returned and value zero (wxMIDI_NO_ERROR) is left in *pError.
If any error occurs, a NULL pointer is returned and the error code is left in *pError.<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pError</I><UL>
Pointer to an wxMidiError variable in which to leave the error code for the Read operation.
</UL><P>

&nbsp;<P>
<B>wxMidiError </B><B>Read</B>(<B>PmEvent </B>*<I>buffer</I>, <B>long</B>* <I>length</I>)<P>
This second Read operation is just a wrapper for the portmidi native Read function. This method is provided in case it is needed but, 
<FONT COLOR="#FF0000">probably, it will be deleted in future versions of wxMidi.
</FONT><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
If there is an overflow in the internal buffer managed by PortMidi, the buffer will be flushed when an the next Read() operetaion will fail with error code wxMIDI_ERROR_BufferOverflow. Normal operation resumes as soon as a new message arrives. The remainder of any partial sysex message will not be considered to be a "new message" and will be flushed as well.<P>


<HR>
<a name="wxMidiInDeviceSetFilter"/>
<H3>wxMidiInDevice::SetFilter</H3>
<B>wxMidiError SetFilter</B>( <B>long </B><I>filters </I>)<P>

Sets filters on an open wxMidiInDevice to drop selected input types.
<FONT COLOR="#FF0000">By default, active sensing messages are filtered.</FONT>. To allow all messages you have to call SetFilter(wxMIDI_NO_FILTER). <P>

Filtering is useful when midi routing or midi thru functionality is being provided by the user application. For example, you may want to exclude timing messages (clock, MTC, start/stop/continue), while allowing note-related messages to pass. Or you may be using a sequencer or drum-machine for MIDI clock information but want to exclude any notes it may play.<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>filters</I><UL>
Filter codes combined with the OR operator (|).
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Example</FONT></B><P>
<PRE>
// Let's filter out active sensing and sysex messages
pMidiIn->SetFilter(wxMIDI_FILT_ACTIVE | wxMIDI_FILT_SYSEX);

</PRE>


<HR>
<a name="wxMidiInDeviceSetChannelMask"/>
<H3>wxMidiInDevice::SetChannelMask</H3>
<B>wxMidiError SetChannelMask</B>( <B>long </B><I>mask </I>)<P>

SetChannelMask() filters incoming messages based on channel. The mask is a 16-bit bitfield corresponding to appropriate channels. By default, messages for all channels are allowed. Macro
<A href="wxMidiConstants.htm#wxMIDI_CHANNEL">wxMIDI_CHANNEL</A>
can assist in preparing this mask. 
<P>


<HR>
<a name="wxMidiInDeviceStartListening"/>
<H3>wxMidiInDevice::StartListening</H3>
<B>wxMidiError StartListening</B>(<B>wxWindow</B>* <I>pWindow</I>, <B>unsigned long </B><I>nPollingRate</I>=50)<P>

This method creates and starts a thread to call Poll() method every <I>nPollingRate </I>
milliseconds, and trigger a wxEVT_MIDI_INPUT command event if a MIDI message has been received and is waiting to be Read().<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pWindow</I><UL>
Pointer to window that will receive the wxEVT_MIDI_INPUT command event s.
</UL><P>
<I>nPollingRate </I><UL>
Polling interval, in milliseconds.
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
This method is useful for dealing with input messages by means of an event handler. See 
<A HREF="wxMidi.htm#wxMidiQuickStartReceiving">Receiving MIDI messages</A>
for an example.<P>


<HR>
<a name="wxMidiInDeviceStopListening"/>
<H3>wxMidiInDevice::StopListening</H3>
<B>wxMidiError StopListening</B>()<P>

Stops a listener thread created in a previous call to 
<A href="#wxMidiInDeviceStartListening">wxMidiInDevice::StartListening</A>.<P>


<!-- ======================================================================================= -->


<HR>
<a name="wxMidiOutDevice"/>
<H2>wxMidiOutDevice</H2>

A wxMidiOutDevice object represents a MIDI stream on which MIDI data traffic can be sent..<P>

<B><FONT COLOR="#FF0000">Derived from</FONT></B><P>
<A href="#wxMidiDevice">wxMidiDevice</A><P>

<B><FONT COLOR="#FF0000">Members</FONT></B><P>
<A href="#wxMidiOutDeviceConstr">wxMidiOutDevice::wxMidiOutDevice</A><BR>
<A href="#wxMidiOutDeviceDestr">wxMidiOutDevice::~wxMidiOutDevice</A><BR>
<A href="#wxMidiOutDeviceAbort">wxMidiOutDevice::Abort</A><BR>
<A href="#wxMidiOutDeviceAllSoundsOff">wxMidiOutDevice::AllSoundsOff</A><BR>
<A href="#wxMidiOutDeviceNoteOff">wxMidiOutDevice::NoteOff</A><BR>
<A href="#wxMidiOutDeviceNoteOn">wxMidiOutDevice::NoteOn</A><BR>
<A href="#wxMidiOutDeviceOpen">wxMidiOutDevice::Open</A><BR>
<A href="#wxMidiOutDeviceProgramChange">wxMidiOutDevice::ProgramChange</A><BR>
<A href="#wxMidiOutDeviceWrite">wxMidiOutDevice::Write</A><BR>
<P>


<HR>
<a name="wxMidiOutDeviceConstr"/>
<H3>wxMidiOutDevice::wxMidiOutDevice</H3>
<B>wxMidiOutDevice</B>(<B>wxMidiDeviceID </B><I>nDevice</I>)<P>

Constructor.<P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>nDevice</I><UL>
The number of the device.  Device numbers (also referred as device IDs) range from 0 to
wxMidiSystem::CountDevices() - 1
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">See also:</FONT></B><P>
<a href="wxMidiSystem.htm#wxMidiSystemCountDevices">wxMidiSystem::CountDevices</a>
<P>


<HR>
<a name="wxMidiOutDeviceDestr"/>
<H3>wxMidiOutDevice::~wxMidiOutDevice</H3>
~<B>wxMidiOutDevice</B>()<P>

Destructor.<P>


<HR>
<a name="wxMidiOutDeviceAbort"/>
<H3>wxMidiOutDevice::Abort</H3>
<B>wxMidiError Abort</B>()<P>

Terminates any outgoing message immediately; this call may result in a partial transmission of a MIDI message. The caller should immediately close the output port .<P>


<HR>
<a name="wxMidiOutDeviceAllSoundsOff"/>
<H3>wxMidiOutDevice::AllSoundsOff</H3>
<B>wxMidiError </B><B>AllSoundsOff</B>()<P>

From time to time, specially during user application debugging, you may encounter 
a situation in which a MIDI
synthesizer sounds as if its keys are "stuck," and it plays continuously as though someone's
still pressing them. Method AllSoundsOff() sends the MIDI device a signal that tells it to stop inmediatelly all sounds. <P>


<HR>
<a name="wxMidiOutDeviceNoteOn"/>
<H3>wxMidiOutDevice::NoteOn</H3>
<B>wxMidiError NoteOn</B>(<B>int </B><I>channel</I>, <B>int </B><I>note</I>, <B>int </B><I>velocity</I>)<P>

Prepares and sends a NoteOn MIDI message.<P>

<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>channel</I><UL>
The number (0 to 15) of the logical channel that will be used to send the message.<P>
</UL>
<I>note</I><UL>
A number in the range 0 to 127 that specifies the note's pitch. Middle C note corresponds to MIDI note 60, middle C # is 61, middle D is 62, and so on.</UL><P>
<I>velocity</I><UL>
Velocity refers to how hard the key, on a MIDI keyboard, was pressed. This parameter controls the volume of the sound to be produced. So you can consider velocity as synonimous with volume. Parameter <I>velocity </I>is 
a value from 0 to 127. A logarithmic scale is recommended, for example:<P>
<TABLE>
<TR><TD>OFF</TD><TD> ppp</TD><TD>pp</TD><TD> p</TD><TD>mp</TD><TD>mf</TD><TD>f</TD><TD>ff        </TD><TD>fff</TD></TR>
<TR><TD>0</TD><TD> 1</TD><TD> 2</TD><TD> 4</TD><TD> 8</TD><TD> 16</TD><TD>32</TD><TD>64</TD><TD>127</TD></TR>
</TABLE>
</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
You must be aware that in MIDI systems, the activation of a particular note and the release of the same note are considered as two separate events. So, after calling method NoteOn() it is necessary to call later to method NoteOff() to stop the sound generator, even if the sound produced by the NoteOn() command is no longer audible due to natural soud extintion because of the chosen intrument (i.e.piano or percussion instruments).<P>


<HR>
<a name="wxMidiOutDeviceNoteOff"/>
<H3>wxMidiOutDevice::NoteOff</H3>

<B>wxMidiError</B> <B>NoteOff</B>(<B>int </B><I>channel</I>, <B>int </B><I>note</I>, <B>int </B><I>velocity</I>)<P>

Prepares and sends a NoteOff MIDI message. It is normally used to 
stop a sound started by a previous call to NoteOn().<P>

<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>channel</I><UL>
The number (0 to 15) of the logical channel that will be used to send the message.
</UL><P>
<I>note</I><UL>
A number in the range 0 to 127 that specifies the note's pitch to stop.</UL><P>
<I>velocity</I><UL>
A number in the range 0 to 127 that specifies the velocity with which the key was released. This information is  usually ignored by MIDI synthesizers.</UL><P> 


<HR>
<a name="wxMidiOutDeviceOpen"/>
<H3>wxMidiOutDevice::Open</H3>

<B>wxMidiError</B> <B>Open</B>(<B>long</B> <I>latency</I>, <B>void * </B><I>pDriverInfo</I> = NULL)<P>

This methods opens a wxMidiOutDevice stream so that it can be used.<P>

<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>latency</I><UL>
latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur (If latency is less than zero, 0 is assumed).
If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. Timestamps are absolute, not relative delays or offsets. In some cases, by using the latency parameter you can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency.</UL><P>
<I>pDriverInfo</I><UL>
pDriverInfo is a pointer to an optional driver specific data structure
containing additional information for device setup or handle processing.
pDriverInfo is never required for correct operation. If not used
pDriverInfo should be NULL.
</UL><P>

<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
Upon success Open() returns zero (wxMIDI_NO_ERROR). If a call to Open() fails a nonzero error code is returned.<P>


<HR>
<a name="wxMidiOutDeviceProgramChange"/>
<H3>wxMidiOutDevice::ProgramChange</H3>
<B>wxMidiError</B> <B>ProgramChange</B>(<B>int </B><I>channel</I>, <B>int </B><I>instrument</I>)<P>

Prepares and sends a ProgramChange MIDI message. This message is used to change the sound (instrument)
assigned to a channel.<P>

<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>channel</I><UL>
The number (0 to 15) of the logical channel whose sound is to be re-programmed
</UL><P>
<I>instrument</I><UL>
A number in the range 0 to 127 that specifies the new instrument sound to assign to the channel.</UL><P>

&nbsp;<P>
<B><FONT COLOR="#FF0000">See also:</FONT></B><P>
<a href="wxMidiDatabaseGM.htm#wxMidiDatabaseGM">wxMidiDatabaseGM</a>
<P>


<HR>
<a name="wxMidiOutDeviceWrite"/>
<H3>wxMidiOutDevice::Write</H3>

<B>wxMidiError Write</B>(<B>wxMidiShortMessage</B>* <I>pMsg</I>)<P>
<B>wxMidiError Write</B>(<B>wxMidiSysExMessage</B>* <I>pMsg</I>)<P>
<B>wxMidiError Write</B>(<B>wxByte</B>* <I>pBytes</I>, <B>wxMidiTimestamp </B><I>when</I>=0)<P>

Sends a MIDI message to the MIDI device represented by the wxMidiOutDevice object.<P>

<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pMsg</I><UL>
Pointer to the wxMidiMessage object (either wxMidiShortMessage or wxMidiSysExMessage)
to send.
</UL><P>
<I>pBytes</I><UL>
String of bytes with the message to send.
</UL><P>
<I>when</I><UL>
Timestamp with the absolute time at which message must be sent. This parameter is
only meaningfull if the device was opened with latency parameter different from zero.
Otherwise messages are sent inmediatelly and parameter Timestamp will be ignored.
</UL><P>

&nbsp;<P>
An additional Write method is provided:<P> 
<B>wxMidiError Write</B>(<B>PmEvent</B>* <I>buffer</I>, <B>long </B><I>length</I>)<P>

This method is just a wrapper for the portmidi native Write function. This method is provided in case it is needed but, 
<FONT COLOR="#FF0000">probably, it will be deleted in future versions of wxMidi.
</FONT><P>

