# ---------------------------------------------------------------------------
# This file contains a number of CMake functions/macros to make life easier.
#
# HAS_WILDCARD() - checks if input string has * or ? in it
#
# ADD_SUBDIRECTORY() - overrides CMake's ADD_SUBDIRECTORY(), remembers what was added
# ADD_LIBRARY() - overrides CMake's ADD_LIBRARY(), remembers what was added
# ADD_EXECUTABLE() - overrides CMake's ADD_EXECUTABLE(), remembers what was added
# ADD_TEST() - overrides CMake's ADD_TEST(), remembers what was added
# ADD_GTEST() - Add a test using Google's GTest, tests for failure.
# ADD_STATIC_ANALYSIS_TEST() - Add test using cppcheck (if available)
#
# ADD_LIBRARY_FULL() - Complete wrapper for ADD_LIBRARY() with many conveniences.
# ADD_EXECUTABLE_FULL() - Complete wrapper for ADD_EXECUTABLE() with many conveniences.
#
# ADD_TARGET_INCLUDE_PATHS() - Easily add multiple include paths to a single target.
# ---------------------------------------------------------------------------

# ===========================================================================
# This file should only be called once during configuration, but the values
# are not cached so it needs to be be run for each configuration.
# Using properties does the trick of storing a variable per configuration run,
# accessible at all scopes, but having it cleared for the next run.
# ===========================================================================

get_property(PROP_CMAKEFUNCTIONS_RUN_ONCE GLOBAL PROPERTY CMAKEFUNCTIONS_RUN_ONCE SET)

if (PROP_CMAKEFUNCTIONS_RUN_ONCE)
    return()
endif()

set_property(GLOBAL PROPERTY CMAKEFUNCTIONS_RUN_ONCE TRUE)

# ===========================================================================
# Find cppcheck for ADD_STATIC_ANALYSIS_TEST() function
# ===========================================================================

# Find the cppcheck program, the var ${cppcheck} will be either the path or "cppcheck-NOTFOUND"
FIND_PROGRAM( cppcheck "cppcheck" )

IF ( ${cppcheck} STREQUAL "cppcheck-NOTFOUND" )
    MESSAGE( STATUS "* WARNING: cppcheck NOT found, NOT generating ADD_STATIC_ANALYSIS_TEST() tests" )
ELSE()
    MESSAGE( STATUS "* cppcheck found, generating ADD_STATIC_ANALYSIS_TEST() tests" )
ENDIF()


# ===========================================================================
# Helper functions
# ===========================================================================

# ---------------------------------------------------------------------------
# Set variable has_wild to TRUE if the file_name contains either '*' or '?'
# Usage : HAS_WILDCARD(has_wild "*.txt") ... if (${has_wild}) ...
# ---------------------------------------------------------------------------

FUNCTION( HAS_WILDCARD has_wild file_name )
    SET(${has_wild} FALSE PARENT_SCOPE)
    STRING(REGEX MATCH "[*?]+" re_match ${file_name})

    if (re_match)
        SET(${has_wild} TRUE PARENT_SCOPE)
    endif()
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Append to the list the file(s) in filename which may be a list and/or contain wildcards.
# Note that CMake lists are simply items separated by a semicolon ';'
# If the filename exists or is wild the path is expanded using file(GLOB ...)
# Usage : ADD_FILE_TO_LIST(myfiles "*.txt") ... myfiles = "a.txt;b.txt;..."
#         ADD_FILE_TO_LIST(myfiles "a.txt;b.jpg") ... myfiles = "a.txt;b.jpg"
# ---------------------------------------------------------------------------

FUNCTION( ADD_FILE_TO_LIST list_name filename allow_missing_files )

    HAS_WILDCARD(is_wild ${filename})

    foreach( f ${filename})
        if (is_wild)
            # Expand the path and handle wildcards
            FILE( GLOB filenames ${filename} )
            SET(${list_name} ${${list_name}} ${filenames} PARENT_SCOPE)
        elseif ((EXISTS ${f}) OR (EXISTS "${CMAKE_CURRENT_LIST_DIR}/${f}"))
            # Cleanup the path
            FILE( GLOB filenames ${filename} )
            SET(${list_name} ${${list_name}} ${filenames} PARENT_SCOPE)
        elseif (allow_missing_files)
            # Just add the file which doesn't exist right now
            SET(${list_name} ${${list_name}} ${f} PARENT_SCOPE)
        else()
            # warn, then add the file which doesn't exist right now anyway
            message(WARNING "File doesn't exist on disk : '${f}' from dir '${CMAKE_CURRENT_LIST_DIR}'")
            SET(${list_name} ${${list_name}} ${f} PARENT_SCOPE)
        endif()
    endforeach()

ENDFUNCTION()

# ---------------------------------------------------------------------------
# Append to the list the object file(s) which would be generated by an
# ADD_EXECUTABLE() or ADD_LIBRARY() call.
# Usage : GET_OBJECT_FILES(blah objlist "a.cpp;b.cpp") ...
#         objlist = "/path/to/.../blah.dir/.../a.obj; .../b.obj or *.o as appropriate.
# ---------------------------------------------------------------------------

FUNCTION( GET_OBJECT_FILES target_name object_list_name source_files )

    if (MSVC)
        foreach(f ${source_files})
            GET_FILENAME_COMPONENT(fname ${f} NAME)
            string(REPLACE ".cpp" ".obj" fname2 ${fname})
            string(REPLACE ".c"   ".obj" fname2 ${fname2})
            SET(objects ${objects} "${CMAKE_CURRENT_BINARY_DIR}/${target_name}.dir/${CMAKE_CFG_INTDIR}/${fname2}")
        endforeach()
    else()
        foreach(f ${source_files})
            GET_FILENAME_COMPONENT(fname ${f} NAME)
            SET(objects ${objects} "${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${target_name}.dir/${fname}.o")
        endforeach()
    endif()

    SET(${object_list_name} ${${object_list_name}} ${objects} PARENT_SCOPE)

ENDFUNCTION()

# ===========================================================================
# Replace some CMake functions to be able to track the targets
# that will be in the generated Makefiles
# ===========================================================================

UNSET(ADD_SUBDIRECTORY_LIST CACHE)
UNSET(ADD_LIBRARY_LIST CACHE)
UNSET(ADD_LIBRARY_DIR_LIST CACHE)
UNSET(ADD_LIBRARY_DIR_NAME_LIST CACHE)
UNSET(ADD_EXECUTABLE_LIST CACHE)
UNSET(ADD_EXECUTABLE_DIR_LIST CACHE)
UNSET(ADD_EXECUTABLE_DIR_NAME_LIST CACHE)
UNSET(ADD_TEST_LIST CACHE)
UNSET(ADD_TEST_DIR_LIST CACHE)
UNSET(ADD_TEST_DIR_NAME_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_DIR_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST CACHE)

# ---------------------------------------------------------------------------
# Print out the ADD_SUBDIRECTORY() projects to show what is available
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_SUBDIRECTORY )
	MESSAGE( STATUS "* Subdirectories that contain generated build files from ADD_SUBDIRECTORY():" )

	LIST(SORT ADD_SUBDIRECTORY_LIST) # ok to sort this list inplace
	STRING(REGEX REPLACE ";" "\n* - " ADD_SUBDIRECTORY_LIST_STR "${ADD_SUBDIRECTORY_LIST}")
	MESSAGE( STATUS "* - ${ADD_SUBDIRECTORY_LIST_STR}")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Print out the ADD_LIBRARY() targets
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_LIBRARY )
    MESSAGE( STATUS "* Library targets that can be built from ADD_LIBRARY():" )

    SET(ADD_LIBRARY_DIR_NAME_LIST_SORTED ${ADD_LIBRARY_DIR_NAME_LIST})
    LIST(SORT ADD_LIBRARY_DIR_NAME_LIST_SORTED)
    STRING(REGEX REPLACE ";" "\n* - " ADD_LIBRARY_DIR_NAME_LIST_SORTED_STR "${ADD_LIBRARY_DIR_NAME_LIST_SORTED}")
    MESSAGE( STATUS "* - ${ADD_LIBRARY_DIR_NAME_LIST_SORTED_STR}")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Print out the ADD_EXECUTABLE() targets
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_EXECUTABLE )
    MESSAGE( STATUS "* Executable targets that can be built from ADD_EXECUTABLE():" )

    SET(ADD_EXECUTABLE_DIR_NAME_LIST_SORTED ${ADD_EXECUTABLE_DIR_NAME_LIST})
    LIST(SORT ADD_EXECUTABLE_DIR_NAME_LIST_SORTED)
    STRING(REGEX REPLACE ";" "\n* - " ADD_EXECUTABLE_DIR_NAME_LIST_SORTED_STR "${ADD_EXECUTABLE_DIR_NAME_LIST_SORTED}")
    MESSAGE( STATUS "* - ${ADD_EXECUTABLE_DIR_NAME_LIST_SORTED_STR}")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_SUBDIRECTORY() function to remember what
# subdirectories were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_SUBDIRECTORY source_dir )

    STRING(REGEX REPLACE "${CMAKE_HOME_DIRECTORY}[/]*" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    IF (PROJ_DIR_TEMP)
        SET(PROJ_DIR_TEMP "${PROJ_DIR_TEMP}/")
    ENDIF()

    IF (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${source_dir}")
        SET(ADD_SUBDIRECTORY_LIST ${ADD_SUBDIRECTORY_LIST} "${PROJ_DIR_TEMP}${source_dir}" CACHE INTERNAL "")
        _ADD_SUBDIRECTORY(${source_dir} ${ARGN})
    ELSE()
        MESSAGE(STATUS "* WARNING: Missing directory in ADD_SUBDIRECTORY(${CMAKE_CURRENT_LIST_DIR}/${source_dir})")
    ENDIF()
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_LIBRARY() function to remember what
# library targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_LIBRARY name)
    _ADD_LIBRARY(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_LIBRARY_LIST     ${ADD_LIBRARY_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_LIBRARY_DIR_LIST ${ADD_LIBRARY_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_LIBRARY_DIR_NAME_LIST ${ADD_LIBRARY_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_EXECUTABLE() function to remember what
# executable targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_EXECUTABLE name)
    _ADD_EXECUTABLE(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_EXECUTABLE_LIST     ${ADD_EXECUTABLE_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_EXECUTABLE_DIR_LIST ${ADD_EXECUTABLE_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_EXECUTABLE_DIR_NAME_LIST ${ADD_EXECUTABLE_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_TEST() function to remember what
# test targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_TEST name)
    _ADD_TEST(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_TEST_LIST     ${ADD_TEST_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_TEST_DIR_LIST ${ADD_TEST_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_TEST_DIR_NAME_LIST ${ADD_TEST_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Add a function to create an ADD_TEST() that properly checks the output
# of Google GTests. Use this function instead of ADD_TEST for running GTests in your exe.
# Usage: ADD_GTEST( existing_exe_target_name [optional args to exe] )
# ---------------------------------------------------------------------------

FUNCTION( ADD_GTEST exe_target_name )
    ADD_TEST(${exe_target_name} ${CMAKE_CURRENT_BINARY_DIR}/${exe_target_name} ${ARGN})
    SET_TESTS_PROPERTIES( ${exe_target_name} PROPERTIES FAIL_REGULAR_EXPRESSION "FAILED" )
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Add a function to call cppcheck to do a static analysis test on the project
# source dir using the cppcheck program.
# This is probably a Linux only test and the target will not be generated if
# you don't have cppcheck installed.
# ---------------------------------------------------------------------------

FUNCTION( ADD_STATIC_ANALYSIS_TEST name )
    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    # Do not add the test if cppcheck is not found
    IF ( NOT ${cppcheck} STREQUAL "cppcheck-NOTFOUND" )
        LIST(FIND ADD_STATIC_ANALYSIS_TEST_DIR_LIST ${PROJ_DIR_TEMP} PROJ_DIR_IDX_TEMP)

        IF ("${PROJ_DIR_IDX_TEMP}" GREATER "-1")
            MESSAGE(STATUS "* WARNING: Duplicate static_analysis tests for dir ${CMAKE_CURRENT_SOURCE_DIR} with names ${name}, you need only one ADD_STATIC_ANALYSIS_TEST per directory.")
        ELSE()
            ADD_TEST( ${name}
                    ${cppcheck}
                    "--verbose"
                    "--quiet"
                    ${CMAKE_CURRENT_SOURCE_DIR}
            )
            SET_TESTS_PROPERTIES( ${name}
                PROPERTIES FAIL_REGULAR_EXPRESSION "(error)")

            SET(ADD_STATIC_ANALYSIS_TEST_LIST     ${ADD_STATIC_ANALYSIS_TEST_LIST}     ${name} CACHE INTERNAL "")
            SET(ADD_STATIC_ANALYSIS_TEST_DIR_LIST ${ADD_STATIC_ANALYSIS_TEST_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
            SET(ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST ${ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
        ENDIF()
    ENDIF()
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Make ADD_LIBRARY a little easier to read by putting together the
# necessary calls into one function.
# Usage:
#   ADD_LIBRARY_FULL( target_name [SHARED] [STATIC] [MODULE] [CUDA] [EXCLUDE_FROM_ALL] [ALLOW_MISSING_FILES]
#       HEADERS                              # can use *.h or "" for no files
#           "*.h" "*.hpp"
#       SOURCES                              # or specify the file names exactly
#           "foo.cpp" "bar.cpp"
#       LINK_LIBRARIES                       # replaces TARGET_LINK_LIBRARIES(target_name lib1 lib2 ...)
#           gtest ${Boost_LIBRARIES}
#       PROPERTIES FOLDER "Msvc/Folder/Name" # replaces SET_TARGET_PROPERTIES(target_name PROPERTIES ...)
#       PROPERTIES LINKER_LANGUAGE CXX ... ) # use PROPERTIES XXX YYY as many times as you like
#
# Internal cached variables will be created:
#   ${target_name}_HEADER_FILES
#   ${target_name}_SOURCE_FILES
#   ${target_name}_OBJECT_FILES
#
# INSTALL() put the lib into CMAKE_INSTALL_PREFIX/bin or lib/ and the
# headers will be put into include/<path>/ from the root CMakeLists file.
# ---------------------------------------------------------------------------

function( ADD_LIBRARY_FULL name )
    set(cmd)                          # current directive we're processing
	set(IS_SHARED)                    # was SHARED directive used
	set(IS_STATIC)                    # was STATIC directive used
	set(IS_MODULE)                    # was MODULE directive used
	set(IS_CUDA FALSE)                # was CUDA directive used
	set(IS_EXCLUDE_FROM_ALL)          # was EXCLUDE_FROM_ALL directive used
    set(IS_ALLOW_MISSING_FILES FALSE) # was ALLOW_MISSING_FILES directive used
    set(HEADERS_LIST)                 # list of header files for library
    set(SOURCES_LIST)                 # list of source files for library
    set(PRECOMPILED_INCLUDE "")       # header include to use as the precompiled header
    set(PRECOMPILED_HEADER)           # header file to use as the precompiled header
    set(PRECOMPILED_SOURCE)           # source file that only includes the precomp header
    set(LINK_LIBRARIES_LIST)          # list of libraries to link to
    set(PROPERTIES_LIST)              # list of SET_TARGET_PROPERTIES

    FOREACH(arg ${ARGN})
        set(read_args FALSE) # TRUE if we didn't find a keyword

		if (${arg} STREQUAL "SHARED")
			set(IS_SHARED "SHARED")
		elseif (${arg} STREQUAL "STATIC")
			set(IS_STATIC "STATIC")
		elseif (${arg} STREQUAL "MODULE")
			set(IS_MODULE "MODULE")
		elseif (${arg} STREQUAL "CUDA")
			set(IS_CUDA TRUE)
		elseif (${arg} STREQUAL "EXCLUDE_FROM_ALL")
			set(IS_EXCLUDE_FROM_ALL "EXCLUDE_FROM_ALL")
		elseif (${arg} STREQUAL "ALLOW_MISSING_FILES")
			set(IS_ALLOW_MISSING_FILES TRUE)
        elseif (${arg} STREQUAL "HEADERS")
            set(cmd "HEADERS")
        elseif (${arg} STREQUAL "SOURCES")
            set(cmd "SOURCES")
        elseif (${arg} STREQUAL "PRECOMPILED_INCLUDE")
            set(cmd "PRECOMPILED_INCLUDE")
        elseif (${arg} STREQUAL "PRECOMPILED_HEADER")
            set(cmd "PRECOMPILED_HEADER")
        elseif (${arg} STREQUAL "PRECOMPILED_SOURCE")
            set(cmd "PRECOMPILED_SOURCE")
        elseif (${arg} STREQUAL "LINK_LIBRARIES")
            set(cmd "LINK_LIBRARIES")
        elseif (${arg} STREQUAL "PROPERTIES")
            set(cmd "PROPERTIES")
        else()
            set(read_args TRUE)
        endif()

        if (read_args)
            if (${cmd} STREQUAL "HEADERS")
                set(HEADERS_LIST ${HEADERS_LIST} ${arg})
                ADD_FILE_TO_LIST(HEADER_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "SOURCES")
                set(SOURCES_LIST ${SOURCES_LIST} ${arg})
                ADD_FILE_TO_LIST(SOURCE_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "PRECOMPILED_INCLUDE")
                set(PRECOMPILED_INCLUDE ${arg})
            elseif (${cmd} STREQUAL "PRECOMPILED_HEADER")
                #set(PRECOMPILED_HEADER ${arg})
                ADD_FILE_TO_LIST(PRECOMPILED_HEADER ${arg} FALSE) # must exist
                ADD_FILE_TO_LIST(HEADER_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "PRECOMPILED_SOURCE")
                #set(PRECOMPILED_SOURCE ${arg})
                # don't add it to the sources yet, but get the abs path to it
                ADD_FILE_TO_LIST(PRECOMPILED_SOURCE ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "LINK_LIBRARIES")
                set(LINK_LIBRARIES_LIST ${LINK_LIBRARIES_LIST} ${arg})
            elseif (${cmd} STREQUAL "PROPERTIES")
                set(PROPERTIES_LIST ${PROPERTIES_LIST} ${arg})
            else()
                MESSAGE(FATAL_ERROR "Unknown directive '${cmd}' in ADD_LIBRARY_FULL")
            endif()
        endif()
    ENDFOREACH(arg)

    SET("${name}_HEADER_FILES" ${HEADER_FILES} CACHE INTERNAL "")
    SET("${name}_SOURCE_FILES" ${SOURCE_FILES} CACHE INTERNAL "")

    set(OBJECT_FILES)
    GET_OBJECT_FILES(${name} OBJECT_FILES "${SOURCE_FILES}" )
    SET("${name}_OBJECT_FILES" ${OBJECT_FILES} CACHE INTERNAL "")

    # Make sure we have at least one file since the error message from ADD_LIBRARY is a little cryptic
    SET(ALL_FILES ${HEADER_FILES} ${SOURCE_FILES})
    LIST(LENGTH ALL_FILES ALL_FILES_COUNT)
    if (${ALL_FILES_COUNT} LESS "1")
        MESSAGE(WARNING "NO files to compile for ${name} in ${CMAKE_CURRENT_SOURCE_DIR}!\n Input headers: '${HEADERS_LIST}' and sources: '${SOURCES_LIST}'")
    endif()

    if (IS_CUDA)
        CUDA_ADD_LIBRARY(${name} ${IS_SHARED} ${IS_STATIC} ${IS_MODULE} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    else()
        ADD_LIBRARY(${name} ${IS_SHARED} ${IS_STATIC} ${IS_MODULE} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    endif()
    TARGET_LINK_LIBRARIES(${name} ${LINK_LIBRARIES_LIST})

    if (DEFINED PROPERTIES_LIST)
        SET_TARGET_PROPERTIES(${name} PROPERTIES ${PROPERTIES_LIST} )
    endif()

    # For precompiled headers in XCode we can set this property, ignored for other compilers.
    if (DEFINED PRECOMPILED_INCLUDE)
        SET_TARGET_PROPERTIES(${name} PROPERTIES XCODE_ATTRIBUTE_GCC_PRECOMPILE_PREFIX_HEADER YES)
        SET_TARGET_PROPERTIES(${name} PROPERTIES XCODE_ATTRIBUTE_GCC_PREFIX_HEADER "${PRECOMPILED_INCLUDE}")
    endif()

    if (NOT "${PRECOMPILED_INCLUDE}" STREQUAL "")
        ADD_PRECOMPILED_HEADER(${name} ${PRECOMPILED_INCLUDE} ${PRECOMPILED_HEADER} ${PRECOMPILED_SOURCE} SOURCE_FILES)
    endif()

    # Set the install includes to use same dir structure as the source directories
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    INSTALL(FILES ${HEADER_FILES} DESTINATION "include/${PROJ_DIR_TEMP}")

    INSTALL(TARGETS ${name}
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

endfunction()

# ---------------------------------------------------------------------------
# Make ADD_EXECUTABLE a little easier to read by putting together the
# necessary calls into one function.
# Usage:
#   ADD_EXECUTABLE_FULL( target_name [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [ALLOW_MISSING_FILES]
#       HEADERS                              # can use *.h or "" for no files
#           "*.h" "*.hpp"
#       SOURCES                              # or specify the file names exactly
#           "foo.cpp" "bar.cpp"
#       LINK_LIBRARIES                       # replaces TARGET_LINK_LIBRARIES(target_name lib1 lib2 ...)
#           gtest ${Boost_LIBRARIES}
#       PROPERTIES FOLDER "Msvc/Folder/Name" # replaces SET_TARGET_PROPERTIES(target_name PROPERTIES ...)
#       PROPERTIES LINKER_LANGUAGE CXX ... ) # use PROPERTIES XXX YYY as many times as you like
#
# Internal cached variables will be created:
#   ${target_name}_HEADER_FILES
#   ${target_name}_SOURCE_FILES
#   ${target_name}_OBJECT_FILES
#
# INSTALL() put the exe into CMAKE_INSTALL_PREFIX/bin.
# ---------------------------------------------------------------------------

function( ADD_EXECUTABLE_FULL name )

    set(cmd)                          # current directive we're processing
    set(IS_WIN32)                     # was WIN32 directive used
    set(IS_MACOSX_BUNDLE)             # was MACOSX_BUNDLE directive used
    set(IS_EXCLUDE_FROM_ALL)          # was EXCLUDE_FROM_ALL directive used
    set(IS_ALLOW_MISSING_FILES FALSE) # was ALLOW_MISSING_FILES directive used
    set(HEADERS_LIST)                 # list of header files for library
    set(SOURCES_LIST)                 # list of source files for library
    set(LINK_LIBRARIES_LIST)          # list of libraries to link to
    set(PROPERTIES_LIST)              # list of SET_TARGET_PROPERTIES

    FOREACH(arg ${ARGN})
        set(read_args FALSE) # TRUE if we didn't find a keyword

        if (${arg} STREQUAL "WIN32")
            set(IS_WIN32 "WIN32")
        elseif (${arg} STREQUAL "MACOSX_BUNDLE")
            set(IS_MACOSX_BUNDLE "MACOSX_BUNDLE")
        elseif (${arg} STREQUAL "EXCLUDE_FROM_ALL")
            set(IS_EXCLUDE_FROM_ALL "EXCLUDE_FROM_ALL")
		elseif (${arg} STREQUAL "ALLOW_MISSING_FILES")
			set(IS_ALLOW_MISSING_FILES TRUE)
        elseif (${arg} STREQUAL "HEADERS")
            set(cmd "HEADERS")
        elseif (${arg} STREQUAL "SOURCES")
            set(cmd "SOURCES")
        elseif (${arg} STREQUAL "LINK_LIBRARIES")
            set(cmd "LINK_LIBRARIES")
        elseif (${arg} STREQUAL "PROPERTIES")
            set(cmd "PROPERTIES")
        else()
            set(read_args TRUE) # dunno what this is
        endif()

        if (read_args)
            if (${cmd} STREQUAL "HEADERS")
                set(HEADERS_LIST ${HEADERS_LIST} ${arg})
                ADD_FILE_TO_LIST(HEADER_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "SOURCES")
                set(SOURCES_LIST ${SOURCES_LIST} ${arg})
                ADD_FILE_TO_LIST(SOURCE_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "LINK_LIBRARIES")
                set(LINK_LIBRARIES_LIST ${LINK_LIBRARIES_LIST} ${arg})
            elseif (${cmd} STREQUAL "PROPERTIES")
                set(PROPERTIES_LIST ${PROPERTIES_LIST} ${arg})
            else()
                MESSAGE(FATAL_ERROR "Unknown directive in ADD_EXECUTABLE_FULL")
            endif()
        endif()
    ENDFOREACH(arg)

    SET("${name}_HEADER_FILES" ${HEADER_FILES} CACHE INTERNAL "")
    SET("${name}_SOURCE_FILES" ${SOURCE_FILES} CACHE INTERNAL "")

    set(OBJECT_FILES)
    GET_OBJECT_FILES(${name} OBJECT_FILES "${SOURCE_FILES}" )
    SET("${name}_OBJECT_FILES" ${OBJECT_FILES} CACHE INTERNAL "")

    # Make sure we have at least one file since the error message from ADD_EXECUTABLE is a little cryptic
    SET(ALL_FILES ${HEADER_FILES} ${SOURCE_FILES})
    LIST(LENGTH ALL_FILES ALL_FILES_COUNT)
    if (${ALL_FILES_COUNT} LESS "1")
        MESSAGE(WARNING "NO files to compile for ${name} in ${CMAKE_CURRENT_SOURCE_DIR}!\n Input headers: '${HEADERS_LIST}' and sources: '${SOURCES_LIST}'")
    endif()

    ADD_EXECUTABLE(${name} ${IS_WIN32} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    TARGET_LINK_LIBRARIES(${name} ${LINK_LIBRARIES_LIST})

    if (DEFINED PROPERTIES_LIST)
        SET_TARGET_PROPERTIES(${name} PROPERTIES ${PROPERTIES_LIST} )
    endif()

    INSTALL(TARGETS ${name}
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

endfunction()

# ---------------------------------------------------------------------------
# This function can be used to add include search paths to library targets.
#
# Usage:
#  ADD_TARGET_INCLUDE_PATHS(name path/to/a.h path/to/b.h)
#
# Parameters:
#  name          - The name of the target to modify,
#                  i.e. the one you created with ADD_LIBRARY(target_name...)
#  INCLUDE_PATHS - Relative paths from the CMakeLists.txt file caller to add
#                  to the compiler's command line to other proto files (its /I or -I option)
# Example:
#  ADD_TARGET_INCLUDE_PATHS(target_name "../Project2/include/" "../Project3/include/")
# ---------------------------------------------------------------------------

function(ADD_TARGET_INCLUDE_PATHS name)

    set(INCLUDE_PATHS_ARGS)

    foreach(INCLUDE_PATH ${ARGN})
        get_filename_component(ABS_INCLUDE_PATH ${INCLUDE_PATH} ABSOLUTE)

        IF (MSVC)
            set(INCLUDE_PATHS_ARGS "${INCLUDE_PATHS_ARGS} /I \"${ABS_INCLUDE_PATH}\"" )
        ELSE()
            set(INCLUDE_PATHS_ARGS "${INCLUDE_PATHS_ARGS} -I ${ABS_INCLUDE_PATH}" )
        ENDIF()

    endforeach()

    APPEND_TARGET_PROPERTIES(${name} PROPERTIES COMPILE_FLAGS ${INCLUDE_PATHS_ARGS})

endfunction()


# ---------------------------------------------------------------------------
# APPEND_TARGET_PROPERTIES() is the same as SET_TARGET_PROPERTIES() except that
# instead of overwriting the property value it appends to the current one.
# append_target_properties(target1 target2 ...
#                          PROPERTIES prop1 value1
#                          prop2 value2 ...)
# ---------------------------------------------------------------------------
function(APPEND_TARGET_PROPERTIES)

    set(TARGETS)                        # list of targets to append props to
    set(PROPERTIES FALSE)
    set(PROP_NAME "")                   # last prop name

    FOREACH(arg ${ARGN})

        if (${PROPERTIES})

            # We get the old prop value, append the new and apply it to each target

            if ("${PROP_NAME}" STREQUAL "")
                set(PROP_NAME ${arg})
            else()
                foreach(t ${TARGETS})
                    GET_TARGET_PROPERTY(old_value ${t} ${PROP_NAME})
                    # If no old value ("old_value-NOTFOUND") then set the variable to empty string
                    IF (NOT ${old_value})
                        SET(old_value "")
                    ENDIF()

                    SET_TARGET_PROPERTIES(${t} PROPERTIES ${PROP_NAME} "${old_value} ${arg}")
                endforeach()

                set(PROP_NAME "")
            endif()

        elseif (${arg} STREQUAL "PROPERTIES")
            set(PROPERTIES TRUE)
        else()
            set(TARGETS ${TARGETS} ${arg})
        endif()
    ENDFOREACH(arg)

    if (NOT ${PROPERTIES})
        message(FATAL_ERROR "Missing PROPERTIES directive in APPEND_TARGET_PROPERTY()")
    endif()
    if (NOT "${PROP_NAME}" STREQUAL "")
        message(FATAL_ERROR "Missing value in PROPERTIES directive in APPEND_TARGET_PROPERTY()")
    endif()
endfunction()

# ---------------------------------------------------------------------------
# APPEND_SOURCE_FILES_PROPERTIES() is the same as SET_SOURCE_FILES_PROPERTIES() except that
# instead of overwriting the property value it appends to the current one.
# set_source_files_properties([file1 [file2 [...]]]
#                              PROPERTIES prop1 value1
#                              [prop2 value2 [...]])
# ---------------------------------------------------------------------------
function(APPEND_SOURCE_FILES_PROPERTIES)

    set(FILES)                          # list of files to append props to
    set(PROPERTIES FALSE)
    set(PROP_NAME "")                   # name of last prop

    FOREACH(arg ${ARGN})

        if (${PROPERTIES})

            # We get the old prop value, append the new and apply it to each target

            if ("${PROP_NAME}" STREQUAL "")
                set(PROP_NAME ${arg})
            else()
                foreach(f ${FILES})
                    get_source_file_property(old_value ${f} ${PROP_NAME})
                    # If no old value ("NOTFOUND") then set the variable to empty string
                    IF (NOT ${old_value})
                        SET(old_value "")
                    ENDIF()

                    SET_SOURCE_FILES_PROPERTIES(${f} PROPERTIES ${PROP_NAME} "${old_value} ${arg}")
                endforeach()

                set(PROP_NAME "")
            endif()

        elseif (${arg} STREQUAL "PROPERTIES")
            set(PROPERTIES TRUE)
        else()
            set(FILES ${FILES} ${arg})
        endif()
    ENDFOREACH(arg)

    if (NOT ${PROPERTIES})
        message(FATAL_ERROR "Missing PROPERTIES directive in APPEND_SOURCE_FILES_PROPERTIES()")
    endif()
    if (NOT "${PROP_NAME}" STREQUAL "")
        message(FATAL_ERROR "Missing value in PROPERTIES directive in APPEND_SOURCE_FILES_PROPERTIES()")
    endif()
endfunction()

# ---------------------------------------------------------------------------
# ADD_PRECOMPILED_HEADER() function to add a precomp header to a target.
# pch_include must be the identical path as used in the #include "pch_include"
# pch_header is the full path to the #include "pch_include"
# pch_source is a souce file that only includes the pch_include and
#     it will be appended to the list of sources, optional, if "" a dummy one will be created.
#
# The pch_source file must NOT be in the list of sources since it will try to
# include the precompiled header which wouldn't have been created until it is compiled.
#
# Usage :
#  set(MYPRJ_SOURCES src/a.cpp src/b.cpp)
#  ADD_PRECOMPILED_HEADER( myproj/precomp.h include/myproj/precomp.h src/precomp.cpp MYPRJ_SOURCES )
# ---------------------------------------------------------------------------

function( ADD_PRECOMPILED_HEADER target_name pch_include pch_header pch_source sources_)

    # Make this shown to people to help debug if it actually works or not.
    # GCC is a little tricky to get right since you have to compile it just right
    # and CMake bizarrely hides flags passed to add_definitions() not starting with -D.
    if ("${BUILD_USE_PRECOMPILED_HEADERS}" STREQUAL "")
        set(BUILD_USE_PRECOMPILED_HEADERS TRUE)
    endif()
    set(BUILD_USE_PRECOMPILED_HEADERS ${BUILD_USE_PRECOMPILED_HEADERS} CACHE BOOL "Enable the use of precompiled headers?" FORCE)

    SET(sources ${${sources_}})

    IF(${BUILD_USE_PRECOMPILED_HEADERS})

    IF(MSVC)
        get_filename_component(precomp_basename ${pch_header} NAME_WE)
        SET(pch_filename "${CMAKE_CURRENT_BINARY_DIR}/$(IntDir)/${precomp_basename}.pch")

        # need to delete this file for clean too, otherwise we get an error
        # about mismatched pch and pdb files.
        set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${pch_filename})

        # we can make the cpp file if none is provided
        if ("${pch_source}" STREQUAL "")
            set(pch_source ${CMAKE_CURRENT_BINARY_DIR}/${precomp_basename}.cpp)
            FILE(WRITE  ${pch_source} "// Precompiled header file generated by CMake\n")
            FILE(APPEND ${pch_source} "#include \"${pch_include}\"\n")
        endif()

        file(TO_CMAKE_PATH "${pch_source}" native_pch_source)

        set(found_pch FALSE)

        foreach( f ${sources} )
            file(TO_CMAKE_PATH "${f}" native_f)

            if ("${native_pch_source}" STREQUAL "${native_f}") 
                set(found_pch TRUE)

                APPEND_SOURCE_FILES_PROPERTIES(${pch_source} PROPERTIES 
                                               COMPILE_FLAGS "/Yc\"${pch_include}\" /Fp\"${pch_filename}\""
                                               OBJECT_OUTPUTS "${pch_filename}")
            else()
                APPEND_SOURCE_FILES_PROPERTIES(${f} PROPERTIES
                                              #COMPILE_FLAGS "/Yu\"${pch_include}\" /Fp\"${pch_filename}\" /FI\"${pch_include}\" "
                                               COMPILE_FLAGS "/Yu\"${pch_include}\" /Fp\"${pch_filename}\" "
                                               OBJECT_DEPENDS "${pch_filename}")
            endif()
        endforeach()       

        if (NOT ${found_pch})
            message(WARNING "* Unable to find precompiled source file '${pch_source}' normalized to '${native_pch_source}' in list of files '${sources}'")
        endif()
    ELSEIF (CMAKE_COMPILER_IS_GNUCXX)

        # We will create the pch in an include tree in the binary dir
        get_filename_component(pch_include_path "${pch_include}" PATH)

        if ("${pch_include_path}" STREQUAL "")
            set(pch_filename "${pch_header}.gch")
            message(STATUS "* NOTE: Precompiled header ${pch_header}.gch created in source dir since it has no path in #include statement and GCC always searches the current dir first.")
        else()
            file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/include/${pch_include_path}")
            set(pch_filename "${CMAKE_CURRENT_BINARY_DIR}/include/${pch_include}.gch")
            include_directories(BEFORE "${CMAKE_CURRENT_BINARY_DIR}/include") # find .gch file before .h file
        endif()

        # need to delete this file for clean too, otherwise we get an error
        # about mismatched pch and pdb files.
        set_directory_properties(PROPERTIES ADDITIONAL_MAKE_CLEAN_FILES ${pch_filename})

        # Compile the gch header using the same flags and includes as a normal cpp file.
        SET (cxx_flags ${CMAKE_CXX_FLAGS})

        if ("${CMAKE_BUILD_TYPE}" STREQUAL "Debug")
            SET (cxx_flags ${cxx_flags} ${CMAKE_CXX_FLAGS_DEBUG})
        endif()

        get_target_property(target_type ${target_name} TYPE) 
        if ("${target_type}" STREQUAL "SHARED_LIBRARY")    # (${BUILD_SHARED_LIBS})
            SET (cxx_flags ${cxx_flags} ${CMAKE_SHARED_LIBRARY_CXX_FLAGS})
        endif()

        #get_target_property(target_defs  ${target_name} COMPILE_DEFINITIONS)
        #get_target_property(target_flags ${target_name} COMPILE_FLAGS)

        GET_DIRECTORY_PROPERTY( defs COMPILE_DEFINITIONS)
        foreach (i ${defs})
            LIST(APPEND cxx_flags "-D${i}")
        endforeach()

        GET_DIRECTORY_PROPERTY(include_dirs INCLUDE_DIRECTORIES)
        foreach (i ${include_dirs})
            LIST(APPEND cxx_flags "-I${i}")
        endforeach()

        LIST(APPEND cxx_flags -c ${pch_header} -o ${pch_filename})
 
        SEPARATE_ARGUMENTS(cxx_flags)

        add_custom_command(OUTPUT "${pch_filename}"
                           COMMAND rm -f ${pch_filename}
                           COMMAND ${CMAKE_CXX_COMPILER} ${CMAKE_CXX_COMPILER_ARG1} ${cxx_flags}
			               DEPENDS "${pch_header}")

        add_custom_target( "${target_name}_precomp" ALL DEPENDS "${pch_filename}")

        add_dependencies(${target_name} ${target_name}_precomp)
    ENDIF()

    ENDIF(${BUILD_USE_PRECOMPILED_HEADERS})

endfunction()

# ---------------------------------------------------------------------------
# ADD_DOXYGEN() function to make adding a doxygen target easy.
# Usage : ADD_DOXYGEN( doc
#                      ${CMAKE_SOURCE_DIR}/build/Doxyfile.in
#                      ${CMAKE_BINARY_DIR}/Doxyfile
#
# ---------------------------------------------------------------------------

function( ADD_DOXYGEN name doxyfile_in doxyfile_out doxygen_working_dir)

    if (NOT DEFINED DOXYGEN_FOUND)
        find_package(Doxygen)
    endif()

    if (DOXYGEN_FOUND)
        configure_file( ${doxyfile_in} ${doxyfile_out} @ONLY )

        add_custom_target( ${name} ${DOXYGEN_EXECUTABLE} ${doxyfile_out}
                           WORKING_DIRECTORY ${doxygen_working_dir}
                           COMMENT "Generate API documentation with Doxygen" VERBATUM )

        message( STATUS "* Doxygen found, run $make ${name} to generate documentation in folder" )
    else()
        message( STATUS "* WARNING: Doxygen NOT found, ${name} target will not be generated" )
    endif (DOXYGEN_FOUND)

endfunction()
