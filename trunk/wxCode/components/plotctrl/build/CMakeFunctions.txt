# ---------------------------------------------------------------------------
# This file contains a number of CMake functions/macros to make life easier.
#
# HAS_WILDCARD() - checks if input string has * or ? in it
#
# ADD_SUBDIRECTORY() - overrides CMake's ADD_SUBDIRECTORY(), remembers what was added 
# ADD_LIBRARY() - overrides CMake's ADD_LIBRARY(), remembers what was added 
# ADD_EXECUTABLE() - overrides CMake's ADD_EXECUTABLE(), remembers what was added 
# ADD_TEST() - overrides CMake's ADD_TEST(), remembers what was added 
# ADD_GTEST() - Add a test using Google's GTest, tests for failure.
# ADD_STATIC_ANALYSIS_TEST() - Add test using cppcheck (if available)
# 
# ADD_LIBRARY_FULL() - Complete wrapper for ADD_LIBRARY() with many conveniences.
# ADD_EXECUTABLE_FULL() - Complete wrapper for ADD_EXECUTABLE() with many conveniences.
#
# ADD_TARGET_INCLUDE_PATHS() - Easily add multiple include paths to a single target.
# ---------------------------------------------------------------------------

# ===========================================================================
# This file should only be called once during configuration, but the values
# are not cached so it needs to be be run for each configuration.
# Using properties does the trick of storing a variable per configuration run,
# accessible at all scopes, but having it cleared for the next run.
# ===========================================================================

get_property(PROP_CMAKEFUNCTIONS_RUN_ONCE GLOBAL PROPERTY CMAKEFUNCTIONS_RUN_ONCE SET)

if (PROP_CMAKEFUNCTIONS_RUN_ONCE)
    return()
endif()

set_property(GLOBAL PROPERTY CMAKEFUNCTIONS_RUN_ONCE TRUE)

# ===========================================================================
# Find cppcheck for ADD_STATIC_ANALYSIS_TEST() function
# ===========================================================================

# Find the cppcheck program, the var ${cppcheck} will be either the path or "cppcheck-NOTFOUND"
FIND_PROGRAM( cppcheck "cppcheck" )

IF ( ${cppcheck} STREQUAL "cppcheck-NOTFOUND" )
    MESSAGE( STATUS "* WARNING: cppcheck NOT found, NOT generating ADD_STATIC_ANALYSIS_TEST() tests" )
ELSE()
    MESSAGE( STATUS "* cppcheck found, generating ADD_STATIC_ANALYSIS_TEST() tests" )
ENDIF()


# ===========================================================================
# Helper functions
# ===========================================================================

# ---------------------------------------------------------------------------
# Set variable has_wild to TRUE if the file_name contains either '*' or '?'
# Usage : HAS_WILDCARD(has_wild "*.txt") ... if (${has_wild}) ...
# ---------------------------------------------------------------------------

FUNCTION( HAS_WILDCARD has_wild file_name )
    SET(${has_wild} FALSE PARENT_SCOPE)
    STRING(REGEX MATCH "[*?]+" re_match ${file_name}) 

    if (re_match)
        SET(${has_wild} TRUE PARENT_SCOPE)
    endif()   
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Append to the list the file(s) in filename which may be a list and/or contain wildcards.
# Note that CMake lists are simply items separated by a semicolon ';'
# If the filename exists or is wild the path is expanded using file(GLOB ...)
# Usage : ADD_FILE_TO_LIST(myfiles "*.txt") ... myfiles = "a.txt;b.txt;..."
#         ADD_FILE_TO_LIST(myfiles "a.txt;b.jpg") ... myfiles = "a.txt;b.jpg"
# ---------------------------------------------------------------------------

FUNCTION( ADD_FILE_TO_LIST list_name filename allow_missing_files )

    HAS_WILDCARD(is_wild ${filename})

    foreach( f ${filename})
        if (is_wild)
            # Expand the path and handle wildcards
            FILE( GLOB filenames ${filename} )               
            SET(${list_name} ${${list_name}} ${filenames} PARENT_SCOPE)
        elseif ((EXISTS ${f}) OR (EXISTS "${CMAKE_CURRENT_LIST_DIR}/${f}"))
            # Cleanup the path
            FILE( GLOB filenames ${filename} )               
            SET(${list_name} ${${list_name}} ${filenames} PARENT_SCOPE)
        elseif (allow_missing_files)
            # Just add the file which doesn't exist right now
            SET(${list_name} ${${list_name}} ${f} PARENT_SCOPE)
        else()
            # warn, then add the file which doesn't exist right now anyway
            message(WARNING "File doesn't exist on disk : '${f}' from dir '${CMAKE_CURRENT_LIST_DIR}'")
            SET(${list_name} ${${list_name}} ${f} PARENT_SCOPE)
        endif()
    endforeach()
    
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Append to the list the object file(s) which would be generated by an 
# ADD_EXECUTABLE() or ADD_LIBRARY() call.
# Usage : GET_OBJECT_FILES(blah objlist "a.cpp;b.cpp") ... 
#         objlist = "/path/to/.../blah.dir/.../a.obj; .../b.obj or *.o as appropriate.
# ---------------------------------------------------------------------------

FUNCTION( GET_OBJECT_FILES target_name object_list_name source_files )

    if (MSVC)
        foreach(f ${source_files})
            GET_FILENAME_COMPONENT(fname ${f} NAME)
            string(REPLACE ".cpp" ".obj" fname2 ${fname}) 
            string(REPLACE ".c"   ".obj" fname2 ${fname2}) 
            SET(objects ${objects} "${CMAKE_CURRENT_BINARY_DIR}/${target_name}.dir/${CMAKE_CFG_INTDIR}/${fname2}")
        endforeach()
    else()
        foreach(f ${source_files})
            GET_FILENAME_COMPONENT(fname ${f} NAME)
            SET(objects ${objects} "${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${target_name}.dir/${fname}.o")
        endforeach()
    endif()

    SET(${object_list_name} ${${object_list_name}} ${objects} PARENT_SCOPE)

ENDFUNCTION()

# ===========================================================================
# Replace some CMake functions to be able to track the targets
# that will be in the generated Makefiles
# ===========================================================================

UNSET(ADD_SUBDIRECTORY_LIST CACHE)
UNSET(ADD_LIBRARY_LIST CACHE)
UNSET(ADD_LIBRARY_DIR_LIST CACHE)
UNSET(ADD_LIBRARY_DIR_NAME_LIST CACHE)
UNSET(ADD_EXECUTABLE_LIST CACHE)
UNSET(ADD_EXECUTABLE_DIR_LIST CACHE)
UNSET(ADD_EXECUTABLE_DIR_NAME_LIST CACHE)
UNSET(ADD_TEST_LIST CACHE)
UNSET(ADD_TEST_DIR_LIST CACHE)
UNSET(ADD_TEST_DIR_NAME_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_DIR_LIST CACHE)
UNSET(ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST CACHE)

# ---------------------------------------------------------------------------
# Print out the ADD_SUBDIRECTORY() projects to show what is available
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_SUBDIRECTORY )
	MESSAGE( STATUS "* Subdirectories that contain generated build files from ADD_SUBDIRECTORY():" )

	LIST(SORT ADD_SUBDIRECTORY_LIST) # ok to sort this list inplace
	STRING(REGEX REPLACE ";" "\n* - " ADD_SUBDIRECTORY_LIST_STR "${ADD_SUBDIRECTORY_LIST}")
	MESSAGE( STATUS "* - ${ADD_SUBDIRECTORY_LIST_STR}")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Print out the ADD_LIBRARY() targets
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_LIBRARY )
    MESSAGE( STATUS "* Library targets that can be built from ADD_LIBRARY():" )

    SET(ADD_LIBRARY_DIR_NAME_LIST_SORTED ${ADD_LIBRARY_DIR_NAME_LIST})
    LIST(SORT ADD_LIBRARY_DIR_NAME_LIST_SORTED) 
    STRING(REGEX REPLACE ";" "\n* - " ADD_LIBRARY_DIR_NAME_LIST_SORTED_STR "${ADD_LIBRARY_DIR_NAME_LIST_SORTED}")
    MESSAGE( STATUS "* - ${ADD_LIBRARY_DIR_NAME_LIST_SORTED_STR}")
ENDFUNCTION()
    
# ---------------------------------------------------------------------------
# Print out the ADD_EXECUTABLE() targets
# ---------------------------------------------------------------------------
FUNCTION( PRINT_ADD_EXECUTABLE )
    MESSAGE( STATUS "* Executable targets that can be built from ADD_EXECUTABLE():" )

    SET(ADD_EXECUTABLE_DIR_NAME_LIST_SORTED ${ADD_EXECUTABLE_DIR_NAME_LIST})
    LIST(SORT ADD_EXECUTABLE_DIR_NAME_LIST_SORTED) 
    STRING(REGEX REPLACE ";" "\n* - " ADD_EXECUTABLE_DIR_NAME_LIST_SORTED_STR "${ADD_EXECUTABLE_DIR_NAME_LIST_SORTED}")
    MESSAGE( STATUS "* - ${ADD_EXECUTABLE_DIR_NAME_LIST_SORTED_STR}")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_SUBDIRECTORY() function to remember what
# subdirectories were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_SUBDIRECTORY source_dir )

    STRING(REGEX REPLACE "${CMAKE_HOME_DIRECTORY}[/]*" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    IF (PROJ_DIR_TEMP)
        SET(PROJ_DIR_TEMP "${PROJ_DIR_TEMP}/")
    ENDIF()

    IF (EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${source_dir}")
        SET(ADD_SUBDIRECTORY_LIST ${ADD_SUBDIRECTORY_LIST} "${PROJ_DIR_TEMP}${source_dir}" CACHE INTERNAL "")
        _ADD_SUBDIRECTORY(${source_dir} ${ARGN})
    ELSE()
        MESSAGE(STATUS "* WARNING: Missing directory in ADD_SUBDIRECTORY(${CMAKE_CURRENT_LIST_DIR}/${source_dir})")
    ENDIF()
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_LIBRARY() function to remember what
# library targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_LIBRARY name)
    _ADD_LIBRARY(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_LIBRARY_LIST     ${ADD_LIBRARY_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_LIBRARY_DIR_LIST ${ADD_LIBRARY_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_LIBRARY_DIR_NAME_LIST ${ADD_LIBRARY_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_EXECUTABLE() function to remember what
# executable targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_EXECUTABLE name)
    _ADD_EXECUTABLE(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_EXECUTABLE_LIST     ${ADD_EXECUTABLE_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_EXECUTABLE_DIR_LIST ${ADD_EXECUTABLE_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_EXECUTABLE_DIR_NAME_LIST ${ADD_EXECUTABLE_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Replace the ADD_TEST() function to remember what
# test targets were added so we can do things with them.
# ---------------------------------------------------------------------------
FUNCTION( ADD_TEST name)
    _ADD_TEST(${name} ${ARGN})

    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    SET(ADD_TEST_LIST     ${ADD_TEST_LIST}     ${name} CACHE INTERNAL "")
    SET(ADD_TEST_DIR_LIST ${ADD_TEST_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
    SET(ADD_TEST_DIR_NAME_LIST ${ADD_TEST_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Add a function to create an ADD_TEST() that properly checks the output
# of Google GTests. Use this function instead of ADD_TEST for running GTests in your exe.
# Usage: ADD_GTEST( existing_exe_target_name [optional args to exe] )
# ---------------------------------------------------------------------------

FUNCTION( ADD_GTEST exe_target_name )    
    ADD_TEST(${exe_target_name} ${CMAKE_CURRENT_BINARY_DIR}/${exe_target_name} ${ARGN})
    SET_TESTS_PROPERTIES( ${exe_target_name} PROPERTIES FAIL_REGULAR_EXPRESSION "FAILED" )
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Add a function to call cppcheck to do a static analysis test on the project
# source dir using the cppcheck program.
# This is probably a Linux only test and the target will not be generated if
# you don't have cppcheck installed.
# ---------------------------------------------------------------------------

FUNCTION( ADD_STATIC_ANALYSIS_TEST name )
    # Get the last part of the directory we're currently in
    #GET_FILENAME_COMPONENT(PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR} NAME)
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    # Do not add the test if cppcheck is not found
    IF ( NOT ${cppcheck} STREQUAL "cppcheck-NOTFOUND" )
        LIST(FIND ADD_STATIC_ANALYSIS_TEST_DIR_LIST ${PROJ_DIR_TEMP} PROJ_DIR_IDX_TEMP)
    
        IF ("${PROJ_DIR_IDX_TEMP}" GREATER "-1")
            MESSAGE(STATUS "* WARNING: Duplicate static_analysis tests for dir ${CMAKE_CURRENT_SOURCE_DIR} with names ${name}, you need only one ADD_STATIC_ANALYSIS_TEST per directory.")
        ELSE()
            ADD_TEST( ${name}
                    ${cppcheck}
                    "--verbose"
                    "--quiet"
                    ${CMAKE_CURRENT_SOURCE_DIR}
            )
            SET_TESTS_PROPERTIES( ${name}
                PROPERTIES FAIL_REGULAR_EXPRESSION "(error)")

            SET(ADD_STATIC_ANALYSIS_TEST_LIST     ${ADD_STATIC_ANALYSIS_TEST_LIST}     ${name} CACHE INTERNAL "")
            SET(ADD_STATIC_ANALYSIS_TEST_DIR_LIST ${ADD_STATIC_ANALYSIS_TEST_DIR_LIST} ${PROJ_DIR_TEMP} CACHE INTERNAL "")
            SET(ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST ${ADD_STATIC_ANALYSIS_TEST_DIR_NAME_LIST} "${PROJ_DIR_TEMP}/${name}" CACHE INTERNAL "")
        ENDIF()
    ENDIF()
ENDFUNCTION()

# ---------------------------------------------------------------------------
# Make ADD_LIBRARY a little easier to read by putting together the 
# necessary calls into one function.
# Usage:
#   ADD_LIBRARY_FULL( target_name [SHARED] [STATIC] [MODULE] [CUDA] [EXCLUDE_FROM_ALL] [ALLOW_MISSING_FILES]
#       HEADERS                              # can use *.h or "" for no files
#           "*.h" "*.hpp"          
#       SOURCES                              # or specify the file names exactly
#           "foo.cpp" "bar.cpp" 
#       LINK_LIBRARIES                       # replaces TARGET_LINK_LIBRARIES(target_name lib1 lib2 ...)
#           gtest ${Boost_LIBRARIES}  
#       PROPERTIES FOLDER "Msvc/Folder/Name" # replaces SET_TARGET_PROPERTIES(target_name PROPERTIES ...)
#       PROPERTIES LINKER_LANGUAGE CXX ... ) # use PROPERTIES XXX YYY as many times as you like
#
# Internal cached variables will be created:
#   ${target_name}_HEADER_FILES
#   ${target_name}_SOURCE_FILES
#   ${target_name}_OBJECT_FILES
#
# INSTALL() put the lib into CMAKE_INSTALL_PREFIX/bin or lib/ and the 
# headers will be put into include/<path>/ from the root CMakeLists file.  
# ---------------------------------------------------------------------------

function( ADD_LIBRARY_FULL name )
    set(cmd)                          # current directive we're processing
	set(IS_SHARED)                    # was SHARED directive used
	set(IS_STATIC)                    # was STATIC directive used
	set(IS_MODULE)                    # was MODULE directive used
	set(IS_CUDA FALSE)                # was CUDA directive used    
	set(IS_EXCLUDE_FROM_ALL)          # was EXCLUDE_FROM_ALL directive used
    set(IS_ALLOW_MISSING_FILES FALSE) # was ALLOW_MISSING_FILES directive used
    set(HEADERS_LIST)                 # list of header files for library
    set(SOURCES_LIST)                 # list of source files for library
    set(LINK_LIBRARIES_LIST)          # list of libraries to link to
    set(PROPERTIES_LIST)              # list of SET_TARGET_PROPERTIES

    FOREACH(arg ${ARGN})
        set(read_args TRUE) # FALSE if we found a keyword
	
		if (${arg} STREQUAL "SHARED")
			set(IS_SHARED "SHARED")	
            set(read_args FALSE)
		elseif (${arg} STREQUAL "STATIC")
			set(IS_STATIC "STATIC")	
            set(read_args FALSE)
		elseif (${arg} STREQUAL "MODULE")
			set(IS_MODULE "MODULE")	
            set(read_args FALSE)
		elseif (${arg} STREQUAL "CUDA")
			set(IS_CUDA TRUE)	
            set(read_args FALSE)
		elseif (${arg} STREQUAL "EXCLUDE_FROM_ALL")
			set(IS_EXCLUDE_FROM_ALL "EXCLUDE_FROM_ALL")	
            set(read_args FALSE)
		elseif (${arg} STREQUAL "ALLOW_MISSING_FILES")
			set(IS_ALLOW_MISSING_FILES TRUE)	
            set(read_args FALSE)
        elseif (${arg} STREQUAL "HEADERS")
            set(cmd "HEADERS")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "SOURCES")
            set(cmd "SOURCES")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "LINK_LIBRARIES")
            set(cmd "LINK_LIBRARIES")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "PROPERTIES")
            set(cmd "PROPERTIES")
            set(read_args FALSE)
        endif()

        if (read_args)
            if (${cmd} STREQUAL "HEADERS")
                set(HEADERS_LIST ${HEADERS_LIST} ${arg})
                ADD_FILE_TO_LIST(HEADER_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "SOURCES")
                set(SOURCES_LIST ${SOURCES_LIST} ${arg})
                ADD_FILE_TO_LIST(SOURCE_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "LINK_LIBRARIES")
                set(LINK_LIBRARIES_LIST ${LINK_LIBRARIES_LIST} ${arg})
            elseif (${cmd} STREQUAL "PROPERTIES")
                set(PROPERTIES_LIST ${PROPERTIES_LIST} ${arg})
            else()
                MESSAGE(FATAL_ERROR "Unknown directive in ADD_LIBRARY_FULL")
            endif()
        endif()
    ENDFOREACH(arg)     
    
    SET("${name}_HEADER_FILES" ${HEADER_FILES} CACHE INTERNAL "")
    SET("${name}_SOURCE_FILES" ${SOURCE_FILES} CACHE INTERNAL "")

    set(OBJECT_FILES)
    GET_OBJECT_FILES(${name} OBJECT_FILES "${SOURCE_FILES}" )
    SET("${name}_OBJECT_FILES" ${OBJECT_FILES} CACHE INTERNAL "")    

    # Make sure we have at least one file since the error message from ADD_LIBRARY is a little cryptic
    SET(ALL_FILES ${HEADER_FILES} ${SOURCE_FILES})
    LIST(LENGTH ALL_FILES ALL_FILES_COUNT)  
    if (${ALL_FILES_COUNT} LESS "1")
        MESSAGE(WARNING "NO files to compile for ${name} in ${CMAKE_CURRENT_SOURCE_DIR}!\n Input headers: '${HEADERS_LIST}' and sources: '${SOURCES_LIST}'")
    endif()
    
    if (IS_CUDA)
        CUDA_ADD_LIBRARY(${name} ${IS_SHARED} ${IS_STATIC} ${IS_MODULE} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    else()
        ADD_LIBRARY(${name} ${IS_SHARED} ${IS_STATIC} ${IS_MODULE} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    endif()
    TARGET_LINK_LIBRARIES(${name} ${LINK_LIBRARIES_LIST})
    
    if (DEFINED PROPERTIES_LIST)
        SET_TARGET_PROPERTIES(${name} PROPERTIES ${PROPERTIES_LIST} )
    endif()

    # Set the install includes to use same dir structure as the source directories
    STRING(REPLACE "${CMAKE_HOME_DIRECTORY}/" "" PROJ_DIR_TEMP ${CMAKE_CURRENT_SOURCE_DIR})

    INSTALL(FILES ${HEADER_FILES} DESTINATION "include/${PROJ_DIR_TEMP}")

    INSTALL(TARGETS ${name}
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

endfunction()

# ---------------------------------------------------------------------------
# Make ADD_EXECUTABLE a little easier to read by putting together the 
# necessary calls into one function.
# Usage:
#   ADD_EXECUTABLE_FULL( target_name [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [ALLOW_MISSING_FILES]
#       HEADERS                              # can use *.h or "" for no files
#           "*.h" "*.hpp"          
#       SOURCES                              # or specify the file names exactly
#           "foo.cpp" "bar.cpp" 
#       LINK_LIBRARIES                       # replaces TARGET_LINK_LIBRARIES(target_name lib1 lib2 ...)
#           gtest ${Boost_LIBRARIES}  
#       PROPERTIES FOLDER "Msvc/Folder/Name" # replaces SET_TARGET_PROPERTIES(target_name PROPERTIES ...)
#       PROPERTIES LINKER_LANGUAGE CXX ... ) # use PROPERTIES XXX YYY as many times as you like
#
# Internal cached variables will be created:
#   ${target_name}_HEADER_FILES
#   ${target_name}_SOURCE_FILES
#   ${target_name}_OBJECT_FILES
#
# INSTALL() put the exe into CMAKE_INSTALL_PREFIX/bin.  
# ---------------------------------------------------------------------------

function( ADD_EXECUTABLE_FULL name )

    set(cmd)                          # current directive we're processing
    set(IS_WIN32)                     # was WIN32 directive used
    set(IS_MACOSX_BUNDLE)             # was MACOSX_BUNDLE directive used
    set(IS_EXCLUDE_FROM_ALL)          # was EXCLUDE_FROM_ALL directive used
    set(IS_ALLOW_MISSING_FILES FALSE) # was ALLOW_MISSING_FILES directive used
    set(HEADERS_LIST)                 # list of header files for library
    set(SOURCES_LIST)                 # list of source files for library
    set(LINK_LIBRARIES_LIST)          # list of libraries to link to
    set(PROPERTIES_LIST)              # list of SET_TARGET_PROPERTIES

    FOREACH(arg ${ARGN})
        set(read_args TRUE) # FALSE if we found a keyword
    
        if (${arg} STREQUAL "WIN32")
            set(IS_WIN32 "WIN32")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "MACOSX_BUNDLE")
            set(IS_MACOSX_BUNDLE "MACOSX_BUNDLE")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "EXCLUDE_FROM_ALL")
            set(IS_EXCLUDE_FROM_ALL "EXCLUDE_FROM_ALL")
            set(read_args FALSE)
		elseif (${arg} STREQUAL "ALLOW_MISSING_FILES")
			set(IS_ALLOW_MISSING_FILES TRUE)	
            set(read_args FALSE)
        elseif (${arg} STREQUAL "HEADERS")
            set(cmd "HEADERS")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "SOURCES")
            set(cmd "SOURCES")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "LINK_LIBRARIES")
            set(cmd "LINK_LIBRARIES")
            set(read_args FALSE)
        elseif (${arg} STREQUAL "PROPERTIES")
            set(cmd "PROPERTIES")
            set(read_args FALSE)
        endif()

        if (read_args)
            if (${cmd} STREQUAL "HEADERS")
                set(HEADERS_LIST ${HEADERS_LIST} ${arg})
                ADD_FILE_TO_LIST(HEADER_FILES ${arg} ${IS_ALLOW_MISSING_FILES})
            elseif (${cmd} STREQUAL "SOURCES")
                set(SOURCES_LIST ${SOURCES_LIST} ${arg})
                ADD_FILE_TO_LIST(SOURCE_FILES ${arg} ${IS_ALLOW_MISSING_FILES})            
            elseif (${cmd} STREQUAL "LINK_LIBRARIES")
                set(LINK_LIBRARIES_LIST ${LINK_LIBRARIES_LIST} ${arg})
            elseif (${cmd} STREQUAL "PROPERTIES")
                set(PROPERTIES_LIST ${PROPERTIES_LIST} ${arg})
            else()
                MESSAGE(FATAL_ERROR "Unknown directive in ADD_EXECUTABLE_FULL")
            endif()
        endif()
    ENDFOREACH(arg)    

    SET("${name}_HEADER_FILES" ${HEADER_FILES} CACHE INTERNAL "")
    SET("${name}_SOURCE_FILES" ${SOURCE_FILES} CACHE INTERNAL "")

    set(OBJECT_FILES)
    GET_OBJECT_FILES(${name} OBJECT_FILES "${SOURCE_FILES}" )
    SET("${name}_OBJECT_FILES" ${OBJECT_FILES} CACHE INTERNAL "")

    # Make sure we have at least one file since the error message from ADD_EXECUTABLE is a little cryptic
    SET(ALL_FILES ${HEADER_FILES} ${SOURCE_FILES})
    LIST(LENGTH ALL_FILES ALL_FILES_COUNT)  
    if (${ALL_FILES_COUNT} LESS "1")
        MESSAGE(WARNING "NO files to compile for ${name} in ${CMAKE_CURRENT_SOURCE_DIR}!\n Input headers: '${HEADERS_LIST}' and sources: '${SOURCES_LIST}'")
    endif()
    
    ADD_EXECUTABLE(${name} ${IS_WIN32} ${IS_EXCLUDE_FROMALL} ${HEADER_FILES} ${SOURCE_FILES})
    TARGET_LINK_LIBRARIES(${name} ${LINK_LIBRARIES_LIST})
    
    if (DEFINED PROPERTIES_LIST)
        SET_TARGET_PROPERTIES(${name} PROPERTIES ${PROPERTIES_LIST} )
    endif()

    INSTALL(TARGETS ${name}
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

endfunction()

# ---------------------------------------------------------------------------
# This function can be used to add include search paths to library targets.
# 
# Usage: 
#  ADD_TARGET_INCLUDE_PATHS(name path/to/a.h path/to/b.h)
#
# Parameters:
#  name          - The name of the target to modify, 
#                  i.e. the one you created with ADD_LIBRARY(target_name...)
#  INCLUDE_PATHS - Relative paths from the CMakeLists.txt file caller to add 
#                  to the compiler's command line to other proto files (its /I or -I option)
# Example:
#  ADD_TARGET_INCLUDE_PATHS(target_name "../Project2/include/" "../Project3/include/")
# ---------------------------------------------------------------------------

function(ADD_TARGET_INCLUDE_PATHS name)

    set(INCLUDE_PATHS_ARGS)
    
    foreach(INCLUDE_PATH ${ARGN})
        get_filename_component(ABS_INCLUDE_PATH ${INCLUDE_PATH} ABSOLUTE)
        
        IF (MSVC)
            set(INCLUDE_PATHS_ARGS "${INCLUDE_PATHS_ARGS} /I \"${ABS_INCLUDE_PATH}\"" )
        ELSE()
            set(INCLUDE_PATHS_ARGS "${INCLUDE_PATHS_ARGS} -I ${ABS_INCLUDE_PATH}" )
        ENDIF()
        
    endforeach()
    
    # Get the old flags so we can append the new paths to it
    GET_TARGET_PROPERTY(TARGET_COMPILE_FLAGS ${name} COMPILE_FLAGS)
    # If no old flags then set the variable to empty string
    IF ("${TARGET_COMPILE_FLAGS}" STREQUAL "TARGET_COMPILE_FLAGS-NOTFOUND")
        SET(TARGET_COMPILE_FLAGS "")
    ENDIF()   
    
    SET_TARGET_PROPERTIES(${name} PROPERTIES COMPILE_FLAGS "${TARGET_COMPILE_FLAGS} ${INCLUDE_PATHS_ARGS}")      
   
endfunction()

# ---------------------------------------------------------------------------
# ADD_DOXYGEN() function to make adding a doxygen target easy.
# Usage : ADD_DOXYGEN( doc
#                      ${CMAKE_SOURCE_DIR}/build/Doxyfile.in
#                      ${CMAKE_BINARY_DIR}/Doxyfile
#
# ---------------------------------------------------------------------------

function( ADD_DOXYGEN name doxyfile_in doxyfile_out doxygen_working_dir)

    if (NOT DEFINED DOXYGEN_FOUND)
        find_package(Doxygen)
    endif()

    if (DOXYGEN_FOUND)
        configure_file( ${doxyfile_in} ${doxyfile_out} @ONLY )
        
        add_custom_target( ${name} ${DOXYGEN_EXECUTABLE} ${doxyfile_out}
                           WORKING_DIRECTORY ${doxygen_working_dir}
                           COMMENT "Generate API documentation with Doxygen" VERBATUM )

        message( STATUS "* Doxygen found, run $make ${name} to generate documentation in folder" )
    else()
        message( STATUS "* WARNING: Doxygen NOT found, ${name} target will not be generated" )
    endif (DOXYGEN_FOUND)

endfunction()
