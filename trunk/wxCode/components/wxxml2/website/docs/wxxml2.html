<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>wxXml2: wxXml2Wrappers and reference counting.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.0 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="wxxml2">wxXml2Wrappers and reference counting.</a></h1>wxXml2Wrapper-derived classes does not use a full Copy-On-Write technique: when copying a wxXml2Wrapper you just create a new wxXml2Wrapper (which requires few bytes and thus this is a very fast operation) which wraps the same libxml2 structure of the original wxXml2Wrapper. Consider the following code: <div class="fragment"><pre class="fragment">                <a class="code" href="classwxXml2Document.html">wxXml2Document</a> doc;
                <a class="code" href="classwxXml2Node.html">wxXml2Node</a> root(doc, <span class="stringliteral">"root_of_doc"</span>);
                
                <span class="comment">// copy the root node</span>
                <a class="code" href="classwxXml2Node.html">wxXml2Node</a> copy(root);
                copy.SetName(<span class="stringliteral">"myroot"</span>);         <span class="comment">// modify the copy</span>
           
                <span class="comment">// save the document</span>
                doc.<a class="code" href="classwxXml2Document.html#a12">Save</a>(....);
</pre></div> The result won't be a document with a root named "root_of_doc" but a document with "myroot" as root's name. This is because deep copies are never performed, unlike, for example, in wxString's COW system where the string is shared until a non-const function is called. The libxml2 structures are always shared with wxXml2Wrapper. This is required since the wrappers around libxml2 structures are created on the fly by the wrapper's getters: this is why you'll see only functions returning objects and not references to objects.<p>
Since the underlying libxml2 structures are always shared, a reference count system is required to <b>avoid</b> things like: <div class="fragment"><pre class="fragment">                <a class="code" href="classwxXml2Node.html">wxXml2Node</a> mynode;
                mynode.Create(...);
                {
                    <span class="comment">// copy and mynode are now sharing the same libxml2 structure</span>
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> copy(mynode);
                    [...]
                } <span class="comment">// "copy" is destroyed: it destroys the libxml2 structure</span>
           
                <span class="comment">// mynode references an invalid memory address: CRASH !</span>
                mynode.<a class="code" href="classwxXml2Node.html#z3_1">AddChild</a>(...);
</pre></div> Without reference counting, the destructor of an xml2 wrapper cannot know if other instances of xml wrappers are sharing the same structure. Performing a deep-copy in the copy constructor would be a problem: XML nodes are all linked together and unlinking a node and then inserting a new one is not so easy (especially for all types of nodes).<p>
The only solution is to use a reference count; but the reference count must be stored in the wrapped structure. How wxXml2Wrapper handle this problem ? Well, all libxml2 structure has a VOID* field called "_private" which can be safely used by external functions to hold user contents. The <a class="el" href="classwxXml2Wrapper.html#b2">GetPrivate()</a> function casts that pointer to a reference to a integer so that it can be used as an int instead of a pointer to void.<p>
With reference counting the destructor of a wxXml2Wrapper knows if it is the only instance of that structure (and in this case it should free the structure) or if other wxXml2Wrappers still own that structure (and in this case it only decreases the refcount): <div class="fragment"><pre class="fragment">                <a class="code" href="classwxXml2Node.html">wxXml2Node</a> mynode;
                mynode.Create(...);
                {
                    <span class="comment">// copy and mynode are now sharing the same libxml2 structure</span>
                    <span class="comment">// and the structure's refcount is set to 2</span>
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> copy(mynode);
                    [...]
                } <span class="comment">// "copy" is destroyed: it decreases the refcount</span>
           
                <span class="comment">// mynode references a valid structure (with refcount = 1)</span>
                mynode.<a class="code" href="classwxXml2Node.html#z3_1">AddChild</a>(...);
</pre></div><p>
Anyway there is another thing to consider: libxml2 implements "recursive destruction". When a node is destroyed, all its children are too. This means that we must also be careful not to break libxml2 memory representation destroying a node's child when it's still linked to its parent. Precisely, when a node (but also a property, a dtd, a namespace...) is part of a wider XML tree, we must *never* delete the node when the relative wxXml2Wrapper is destroyed. This is why all wxXml2Wrappers must implement the <a class="el" href="classwxXml2Wrapper.html#a2">IsUnlinked()</a> function: the <a class="el" href="classwxXml2Wrapper.html#a4">DestroyIfUnlinked()</a> function uses it to find when nodes are unlinked from a wider tree and thus must be destroyed by xml2 wrapper. However, this rises another problem ! Consider the example below: <div class="fragment"><pre class="fragment">                <span class="comment">// we'll now build an XML tree</span>
                {
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> root;
                    root.Create(...);
           
                    <span class="comment">// we are going to create a child of the "root" element...</span>
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> child(root, ...);
            
                } <span class="comment">// which one of the "root" and "child" element will be destroyed</span>
                  <span class="comment">// first ? If the "child" destructor is called before the "root"'s one</span>
                  <span class="comment">// then there are no problems: child::IsUnlinked() will return FALSE</span>
                  <span class="comment">// and "child" destructor will do nothing. Then the "root" destructor</span>
                  <span class="comment">// will delete everything.</span>
           
                  <span class="comment">// What happens if the "root" destructor is called first ?</span>
                  <span class="comment">// the root::IsUnlinked() function will return TRUE, root::refcount</span>
                  <span class="comment">// is set to one; the "root" destructor will destroy the structure</span>
                  <span class="comment">// and libxml2 will free the memory of all its children too.</span>
                  <span class="comment">// then, "child" destructor is called and it references an invalid</span>
                  <span class="comment">// memory address: CRASH !</span>
</pre></div><p>
How can we solve this problem ? One solution could be not only to check if the node is unlinked but also to check if all children refcounts are set to zero, in each node destructor. However, I did not implement this solution because it can make all wxxml2 wrappers very slow: wxXml2Nodes are continuosly created &amp; destroyed. The solution I adopted is simply to force the user (you!) to call the <a class="el" href="classwxXml2Wrapper.html#a4">wxXml2Wrapper::DestroyIfUnlinked()</a> function in the right order. This approach is not more restrictive of the approach used, for example, by libxml++ which uses pointers and thus require the DELETE calls to be in the right order. The example above must thus be rewritten as: <div class="fragment"><pre class="fragment">                <span class="comment">// we'll now build an XML tree</span>
                {
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> root;
                    root.Create(...);
           
                    <span class="comment">// we are going to create a child of the "root" element...</span>
                    <a class="code" href="classwxXml2Node.html">wxXml2Node</a> child(root, ...);
            
                    <span class="comment">// destroy the nodes in the right order:</span>
                    <span class="comment">// first children and then the root element</span>
                    <span class="comment">// (which will be the only element to do a real call</span>
                    <span class="comment">//  to the xmlFreeXXXX function)</span>
                    child.<a class="code" href="classwxXml2Wrapper.html#a4">DestroyIfUnlinked</a>();  <span class="comment">// this sets "child" as empty</span>
                    root.<a class="code" href="classwxXml2Wrapper.html#a4">DestroyIfUnlinked</a>();   <span class="comment">// this destroys the tree</span>
            
                    <span class="comment">// if we try to access the "child" or "root" element</span>
                    <span class="comment">// we'll find that they are set to empty elements: in this</span>
                    <span class="comment">// way the order used by the compiler to call the destructors</span>
                    <span class="comment">// of the nodes does not care...</span>
                } 
</pre></div> So, as general rule, when using wxXml2Wrapper-derived classes, you <b>must always call the wxXmlWrapper::DestroyIfUnlinked functions in the right order: first the DestroyIfUnlinked functions of all children and then, as last, the DestroyIfUnlinked function of the node containing all the others.</b> <hr size="1"><address style="align: right;"><small>Generated on Tue Jan 4 18:07:26 2005 for wxXml2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.0 </small></address>
</body>
</html>
