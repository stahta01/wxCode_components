/////////////////////////////////////////////////////////////////////////////
// Name:        msw/spinreal.cpp
// Purpose:     wxSpinReal class implementation for Win32
// Author:      Vadim Zeitlin
// Modified by:
// Created:     22.07.99
// RCS-ID:      $Id: spinrealm.cpp,v 1.1.1.1 2003-12-28 21:05:22 wyo Exp $
// Copyright:   (c) Vadim Zeitlin
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

// ============================================================================
// declarations
// ============================================================================

#ifdef __GNUG__
    #pragma implementation "spinrealbase.h"
    #pragma implementation "spinreal.h"
#endif

// ----------------------------------------------------------------------------
// headers
// ----------------------------------------------------------------------------

// for compilers that support precompilation, includes "wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif

#if wxUSE_SPINCTRL

#if defined(__WIN95__)

#include "wx/spinreal.h"
#include "wx/msw/private.h"

#if defined(__WIN95__) && !(defined(__GNUWIN32_OLD__) || defined(__TWIN32__))
    #include <commctrl.h>
#endif

#include <limits.h>         // for INT_MIN

// ----------------------------------------------------------------------------
// macros
// ----------------------------------------------------------------------------

IMPLEMENT_DYNAMIC_CLASS(wxSpinReal, wxControl)

BEGIN_EVENT_TABLE(wxSpinReal, wxSpinButton)
    EVT_CHAR(wxSpinReal::OnChar)
    EVT_KEY_DOWN(wxSpinReal::OnKey)
    EVT_KEY_UP(wxSpinReal::OnKey)
//    EVT_SPIN(-1, wxSpinReal::OnSpinChange)
    EVT_SPIN_UP(-1, wxSpinReal::OnSpinUp)
    EVT_SPIN_DOWN(-1, wxSpinReal::OnSpinDown)
END_EVENT_TABLE()

#define GetBuddyHwnd()      (HWND)(m_hwndBuddy)

// ----------------------------------------------------------------------------
// constants
// ----------------------------------------------------------------------------

// the margin between the up-down control and its buddy (can be arbitrary,
// choose what you like - or may be decide during run-time depending on the
// font size?)
static const int MARGIN_BETWEEN = 1;

// ============================================================================
// implementation
// ============================================================================

wxArraySpinReals wxSpinReal::ms_allSpins;

// ----------------------------------------------------------------------------
// wnd proc for the buddy text ctrl
// ----------------------------------------------------------------------------

LRESULT APIENTRY _EXPORT wxBuddyTextWndProc(HWND hwnd,
                                            UINT message,
                                            WPARAM wParam,
                                            LPARAM lParam)
{
    wxSpinReal *spin = (wxSpinReal *)::GetWindowLong(hwnd, GWL_USERDATA);

    // forward some messages (the key ones only so far) to the spin ctrl
    switch ( message )
    {
        case WM_CHAR:
        case WM_DEADCHAR:
        case WM_KEYUP:
        case WM_KEYDOWN:
            spin->MSWWindowProc(message, wParam, lParam);

            // The control may have been deleted at this point, so check.
            if (!(::IsWindow(hwnd) && ((wxSpinReal *)::GetWindowLong(hwnd, GWL_USERDATA)) == spin))
                return 0;
            break;
    }
    return ::CallWindowProc(CASTWNDPROC spin->GetBuddyWndProc(),
                            hwnd, message, wParam, lParam);
}

/* static */
wxSpinReal *wxSpinReal::GetSpinForTextCtrl(WXHWND hwndBuddy)
{
    wxSpinReal *spin = (wxSpinReal *)::GetWindowLong((HWND)hwndBuddy,
                                                     GWL_USERDATA);

    int i = ms_allSpins.Index(spin);

    if ( i == wxNOT_FOUND )
        return NULL;

    // sanity check
    wxASSERT_MSG( spin->m_hwndBuddy == hwndBuddy,
                  _T("wxSpinReal has incorrect buddy HWND!") );

    return spin;
}

// process a WM_COMMAND generated by the buddy text control
bool wxSpinReal::ProcessTextCommand(WXWORD cmd, WXWORD WXUNUSED(id))
{
    switch (cmd)
    {
    case EN_CHANGE:
        {
            wxCommandEvent event(wxEVT_COMMAND_TEXT_UPDATED, GetId());
            event.SetEventObject(this);
            wxString val = wxGetWindowText(m_hwndBuddy);
            SetValue( val );
            event.SetString(val);
            event.SetInt((int)GetValue());
            return GetEventHandler()->ProcessEvent(event);
        }
    case EN_SETFOCUS:
    case EN_KILLFOCUS:
        {
            wxFocusEvent event(cmd == EN_KILLFOCUS ? wxEVT_KILL_FOCUS
                    : wxEVT_SET_FOCUS,
                    m_windowId);
            event.SetEventObject( this );
            return GetEventHandler()->ProcessEvent(event);
        }
     default:
        break;
    }

    // not processed
    return FALSE;
}

void wxSpinReal::OnChar(wxKeyEvent& event)
{
    bool process_spinevent = FALSE;

    switch ( event.KeyCode() )
    {
        case WXK_RETURN:
            {
                wxCommandEvent event(wxEVT_COMMAND_TEXT_ENTER, m_windowId);
                InitCommandEvent(event);
                wxString val = wxGetWindowText(m_hwndBuddy);
                SetValue( val );
                event.SetString(val);
                event.SetInt((int)GetValue());
                GetEventHandler()->ProcessEvent(event);
                process_spinevent = TRUE;
                break;
            }

        case WXK_TAB:
            // always produce navigation event - even if we process TAB
            // ourselves the fact that we got here means that the user code
            // decided to skip processing of this TAB - probably to let it
            // do its default job.
            {
                wxNavigationKeyEvent eventNav;
                eventNav.SetDirection(!event.ShiftDown());
                eventNav.SetWindowChange(event.ControlDown());
                eventNav.SetEventObject(this);

                if ( GetParent()->GetEventHandler()->ProcessEvent(eventNav) )
                    return;
                break;
            }
        case WXK_UP :
             {
                 SetValue( m_value + m_increment * m_modifier );
                 process_spinevent = TRUE;
                 break;
             }
        case WXK_DOWN :
             {
                 SetValue( m_value - m_increment * m_modifier );
                 process_spinevent = TRUE;
                 break;
             }
        case WXK_PRIOR :
             {
                 SetValue( m_value + 10.0 * m_increment * m_modifier );
                 process_spinevent = TRUE;
                 break;
             }
        case WXK_NEXT :
             {
                 SetValue( m_value - 10.0 * m_increment * m_modifier );
                 process_spinevent = TRUE;
                 break;
             }
        default :
             break;
    }

    if (process_spinevent)
    {
        wxCommandEvent eventSpin(wxEVT_COMMAND_SPINCTRL_UPDATED, GetId());
        eventSpin.SetEventObject(this);
        eventSpin.SetInt((int)GetValue());
        eventSpin.SetString(wxGetWindowText(m_hwndBuddy));

        (void)GetEventHandler()->ProcessEvent(eventSpin);
    }

    // no, we didn't process it
    event.Skip();
}

void wxSpinReal::OnKey(wxKeyEvent& event)
{
    m_modifier = 1.0;

    // in GTK XxxDown() & m_xxxDown report state before keypress
    // in MSW report state after keypress
    if ( event.ShiftDown() ) m_modifier = 10.0;
    if ( event.ControlDown() ) m_modifier *= 100.0;

    // note: in gtk CTRL PG-UP/DOWN goes to MAX/MIN
    //       in MSW, ALT reserved for menubar

    event.Skip();
}

// ----------------------------------------------------------------------------
// construction
// ----------------------------------------------------------------------------

bool wxSpinReal::Create(wxWindow *parent,
                        wxWindowID id,
                        const wxString& value,
                        const wxPoint& pos,
                        const wxSize& size,
                        long style,
                        float min, float max,
                        float initial,
                        float increment, int digits,
                        const wxString& name)
{
    // before using DoGetBestSize(), have to set style to let the base class
    // know whether this is a horizontal or vertical control (we're always
    // vertical)
    style |= wxSP_VERTICAL;
    SetWindowStyle(style);

    // calculate the sizes: the size given is the toal size for both controls
    // and we need to fit them both in the given width (height is the same)
    wxSize sizeText(size), sizeBtn(size);
    sizeBtn.x = wxSpinButton::DoGetBestSize().x;
    if ( sizeText.x <= 0 )
    {
        // DEFAULT_ITEM_WIDTH is the default width for the text control
        sizeText.x = DEFAULT_ITEM_WIDTH + MARGIN_BETWEEN + sizeBtn.x;
    }

    sizeText.x -= sizeBtn.x + MARGIN_BETWEEN;
    if ( sizeText.x <= 0 )
    {
        wxLogDebug(_T("not enough space for wxSpinReal!"));
    }

    wxPoint posBtn(pos);
    posBtn.x += sizeText.x + MARGIN_BETWEEN;

    // create the spin button
    if ( !wxSpinButton::Create(parent, id, posBtn, sizeBtn, style, name) )
    {
        return FALSE;
    }

    bool want3D;
    WXDWORD exStyle = Determine3DEffects(WS_EX_CLIENTEDGE, &want3D);
    int msStyle = WS_CHILD;

    // Even with extended styles, need to combine with WS_BORDER for them to
    // look right.
    if ( want3D || wxStyleHasBorder(style) )
        msStyle |= WS_BORDER;

    // create the text window
    m_hwndBuddy = (WXHWND)::CreateWindowEx
                    (
                     exStyle,                // sunken border
                     _T("EDIT"),             // window class
                     NULL,                   // no window title
                     msStyle /* | WS_CLIPSIBLINGS */,   // style (will be shown later)
                     pos.x, pos.y,           // position
                     0, 0,                   // size (will be set later)
                     GetHwndOf(parent),      // parent
                     (HMENU)-1,              // control id
                     wxGetInstance(),        // app instance
                     NULL                    // unused client data
                    );

    if ( !m_hwndBuddy )
    {
        wxLogLastError(wxT("CreateWindow(buddy text window)"));

        return FALSE;
    }

    // subclass the text ctrl to be able to intercept some events
    m_wndProcBuddy = (WXFARPROC)::GetWindowLong(GetBuddyHwnd(), GWL_WNDPROC);
    ::SetWindowLong(GetBuddyHwnd(), GWL_USERDATA, (LONG)this);
    ::SetWindowLong(GetBuddyHwnd(), GWL_WNDPROC, (LONG)wxBuddyTextWndProc);

    // should have the same font as the other controls
    SetFont(GetParent()->GetFont());

    // set the size of the text window - can do it only now, because we
    // couldn't call DoGetBestSize() before as font wasn't set
    if ( sizeText.y <= 0 )
    {
        int cx, cy;
        wxGetCharSize(GetHWND(), &cx, &cy, &GetFont());

        sizeText.y = EDIT_HEIGHT_FROM_CHAR_HEIGHT(cy);
    }

    DoMoveWindow(pos.x, pos.y,
                 sizeText.x + sizeBtn.x + MARGIN_BETWEEN, sizeText.y);

    (void)::ShowWindow(GetBuddyHwnd(), SW_SHOW);

    // associate the text window with the spin button
    // This is how SpinButton passes int to textctrl
//    (void)::SendMessage(GetHwnd(), UDM_SETBUDDY, (WPARAM)m_hwndBuddy, 0);

    SetRange(min, max);
    m_value = initial;
    SetIncrement(increment, digits);
    m_modifier = 1.0;
    m_snap = FALSE;
    if ( !value.IsEmpty() ) SetValue(value);
    else SetValue(m_value);

    // do it after finishing with m_hwndBuddy creation to avoid generating
    // initial wxEVT_COMMAND_TEXT_UPDATED message
    ms_allSpins.Add(this);

    return TRUE;
}

wxSpinReal::~wxSpinReal()
{
    ms_allSpins.Remove(this);

    // destroy the buddy window because this pointer which wxBuddyTextWndProc
    // uses will not soon be valid any more
    ::DestroyWindow(GetBuddyHwnd());
}

// ----------------------------------------------------------------------------
// wxTextCtrl-like methods
// ----------------------------------------------------------------------------

void wxSpinReal::SetValue(const wxString& text)
{
    if ( !::SetWindowText(GetBuddyHwnd(), text.c_str()) )
    {
        wxLogLastError(wxT("SetWindowText(buddy)"));
    }
}
void wxSpinReal::SetValue( float value )
{
    if ( (value >= m_min) && (value <= m_max))
    {
        if ( m_snap )
        {
            m_value = floor(m_value/m_increment + .5) * m_increment;
        }
        wxString text;
        text.Printf( m_textformat.c_str(), value );
        SetValue( text );
//        if ( !::SetWindowText(GetBuddyHwnd(), text.c_str()) )
//        {
//            wxLogLastError(wxT("SetWindowText(buddy)"));
//        }
        m_value = value;
    }
}

void wxSpinReal::SetRange(float minVal, float maxVal)
{
    m_min = minVal;
    m_max = maxVal;
}

// set the value to step by when spinbutton pressed
// also set the format of the spinctrl to this many decimals
void wxSpinReal::SetIncrement( float increment, int digits )
{
    if (increment == 0) m_increment = .1;  // need for snap
    else m_increment = increment;

    if (digits == -1)
    {
        // calculate the number of digits to show from increment
        // MAX allowed digits in GTK is 5
        wxString increment_str;
        increment_str.Printf( "%f", m_increment );
        digits = increment_str.Find('.');

        int i = 0;
        for ( i=increment_str.Len()-1; i>digits; i-- ){
            if ( increment_str.GetChar(i) != '0' )
            {
                digits = i - digits;
                break;
            }
        }
    }
    // check validity of digits
    if ( (digits < 0) || (digits > 5) ) digits = 5;

    m_textformat.Printf( "%%.%df", digits );
}

void wxSpinReal::SetSnap(bool snap_to_increment)
{
    m_snap = snap_to_increment;
    SetValue(m_value);
}

float wxSpinReal::GetValue()
{
    wxString val = wxGetWindowText(m_hwndBuddy);

    float n;
    if ( (wxSscanf(val, wxT("%f"), &n) != 1) )
        n = 0.0;

    return n;
}

// ----------------------------------------------------------------------------
// forward some methods to subcontrols
// ----------------------------------------------------------------------------

bool wxSpinReal::SetFont(const wxFont& font)
{
    if ( !wxWindowBase::SetFont(font) )
    {
        // nothing to do
        return FALSE;
    }

    WXHANDLE hFont = GetFont().GetResourceHandle();
    (void)::SendMessage(GetBuddyHwnd(), WM_SETFONT, (WPARAM)hFont, TRUE);

    return TRUE;
}

bool wxSpinReal::Show(bool show)
{
    if ( !wxControl::Show(show) )
    {
        return FALSE;
    }

    ::ShowWindow(GetBuddyHwnd(), show ? SW_SHOW : SW_HIDE);

    return TRUE;
}

bool wxSpinReal::Enable(bool enable)
{
    if ( !wxControl::Enable(enable) )
    {
        return FALSE;
    }

    ::EnableWindow(GetBuddyHwnd(), enable);

    return TRUE;
}

void wxSpinReal::SetFocus()
{
    ::SetFocus(GetBuddyHwnd());
}

// ----------------------------------------------------------------------------
// event processing
// ----------------------------------------------------------------------------

void wxSpinReal::OnSpinChange(wxSpinEvent& eventSpin)
{
    wxCommandEvent event(wxEVT_COMMAND_SPINCTRL_UPDATED, GetId());
    event.SetEventObject(this);
    event.SetInt(eventSpin.GetPosition());
    event.SetString(wxGetWindowText(m_hwndBuddy));

    (void)GetEventHandler()->ProcessEvent(event);

    if ( eventSpin.GetSkipped() )
    {
        event.Skip();
    }
}

void wxSpinReal::OnSpinUp(wxSpinEvent& eventSpin)
{
     if ( (m_value + m_increment * m_modifier) < m_max )
     {
        m_value += m_increment * m_modifier;
        SetValue(m_value);
     }
     OnSpinChange(eventSpin);
     eventSpin.Skip();
}

void wxSpinReal::OnSpinDown(wxSpinEvent& eventSpin)
{
     if ( (m_value - m_increment * m_modifier) > m_min )
     {
        m_value -= m_increment * m_modifier;
        SetValue(m_value);
     }
     OnSpinChange(eventSpin);
     eventSpin.Skip();
}

// ----------------------------------------------------------------------------
// size calculations
// ----------------------------------------------------------------------------

wxSize wxSpinReal::DoGetBestSize() const
{
    wxSize sizeBtn = wxSpinButton::DoGetBestSize();
    sizeBtn.x += DEFAULT_ITEM_WIDTH + MARGIN_BETWEEN;

    int y;
    wxGetCharSize(GetHWND(), NULL, &y, &GetFont());
    y = EDIT_HEIGHT_FROM_CHAR_HEIGHT(y);

    if ( sizeBtn.y < y )
    {
        // make the text tall enough
        sizeBtn.y = y;
    }

    return sizeBtn;
}

void wxSpinReal::DoMoveWindow(int x, int y, int width, int height)
{
    int widthBtn = wxSpinButton::DoGetBestSize().x;
    int widthText = width - widthBtn - MARGIN_BETWEEN;
    if ( widthText <= 0 )
    {
        wxLogDebug(_T("not enough space for wxSpinReal!"));
    }

    if ( !::MoveWindow(GetBuddyHwnd(), x, y, widthText, height, TRUE) )
    {
        wxLogLastError(wxT("MoveWindow(buddy)"));
    }

    x += widthText + MARGIN_BETWEEN;
    if ( !::MoveWindow(GetHwnd(), x, y, widthBtn, height, TRUE) )
    {
        wxLogLastError(wxT("MoveWindow"));
    }
}

// get total size of the control
void wxSpinReal::DoGetSize(int *x, int *y) const
{
    RECT spinrect, textrect, ctrlrect;
    GetWindowRect(GetHwnd(), &spinrect);
    GetWindowRect(GetBuddyHwnd(), &textrect);
    UnionRect(&ctrlrect,&textrect, &spinrect);

    if ( x )
        *x = ctrlrect.right - ctrlrect.left;
    if ( y )
        *y = ctrlrect.bottom - ctrlrect.top;
}

void wxSpinReal::DoGetPosition(int *x, int *y) const
{
    // hack: pretend that our HWND is the text control just for a moment
    WXHWND hWnd = GetHWND();
    wxConstCast(this, wxSpinReal)->m_hWnd = m_hwndBuddy;

    wxSpinButton::DoGetPosition(x, y);

    wxConstCast(this, wxSpinReal)->m_hWnd = hWnd;
}

#endif // __WIN95__

#endif
       // wxUSE_SPINCTRL

